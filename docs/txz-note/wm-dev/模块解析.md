### -.模块加载

整个V3模块完全基于V3ApplicationContextLoader加载器完成对整个项目的分段加载，他会将不同的配置文件按照出处进行模块分类(一个jar中的全部配置文件算同一类)，在遍历加载：

web容器启动时会通过ContextLoaderListener加载一些初始化的配置信息：

```java
public class V3ContextLoaderListener extends ContextLoaderListener {
    protected final transient Logger logger = LoggerFactory.getLogger(this.getClass());
    public V3ContextLoaderListener() {}
    public V3ContextLoaderListener(WebApplicationContext context) {super(context);}
    protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) {
        ArrayList<String> locations = new ArrayList();
        locations.add("classpath*:applicationContext-v3.xml");
		//....
        locations.add("classpath*:/META-INF/v3-spring-plugin-*.xml");
        wac.setConfigLocations((String[])locations.toArray(new String[0]));
        super.configureAndRefreshWebApplicationContext(wac, sc);
    }
}
```

加载初始化配置值信息后会形成一个根spring容器，这个容器在创建V3ApplicationContextLoader时，就会触发V3框架的的核心内容加载对象执行afterPropertiesSet()方法：

```java
//V3ApplicationContextLoader
public void afterPropertiesSet() throws Exception {
    if (!StringUtils.hasText(this.sourcePackagePath)) {
        this.sourcePackagePath = "/META-INF/v3/applicationContext-";
    }

    LicenseValidation lv = this.createLv();
    this.servletContext.setAttribute("_v3_license_validation", lv);
    this.loadV3Context();
}

==================
protected final void loadV3Context() throws Exception {
	//....
    final Map<String, Resource[]> moduleResources = this.getV34SpringResource();
    //....
}
==================
protected Map<String, Resource[]> getV34SpringResource() throws IOException {
    return ClasspathResourceUtils.getSpringResource(this.sourcePackagePath);
}
==================
public static Map<String, Resource[]> getSpringResource(String sourcePackagePath) throws IOException {
    Map<String, ArrayList<Resource>> tempResult = new HashMap();
    Resource[] v3Resources = (new PathMatchingResourcePatternResolver()).getResources("classpath*:" + sourcePackagePath + "*.*");
    Resource[] var3 = v3Resources;
    int var4 = v3Resources.length;

    for(int var5 = 0; var5 < var4; ++var5) {
        Resource resource = var3[var5];
        String modulePackage = ModuleIdUtils.getModulePackage(resource, sourcePackagePath);
        ArrayList<Resource> tempResourceList = (ArrayList)tempResult.get(modulePackage);
        if (tempResourceList == null) {
            tempResourceList = new ArrayList();
            tempResult.put(modulePackage, tempResourceList);
        }

        tempResourceList.add(resource);
    }
    //.....
}
```

之后可以在V3ApplicationContextLoader中遍历这些模块，对于每一个模块而言都会创建一个ModuleApplicationContext对象来存储模块的对象；ModuleApplicationContext继承于AbstractRefreshableConfigApplicationContext，也就是是说ModuleApplicationContext是一个独立的Spring容器，这样每个模块都会创建一个Spring容器来存储管理模块中的bean，模块和模块之间互相独立存在。

```java
moduleApplicationContext = new ModuleApplicationContext(curentModuleId, (Resource[])entry.getValue(), this);

public class ModuleApplicationContext extends AbstractRefreshableConfigApplicationContext implements ModuleContext, Comparable<ModuleContext> {
    protected Resource[] resource = null;
    protected ModuleInfo moduleInfo = null;
    protected V3Context v3Context = null;
    private ServletContext servletContext;
    private ServletConfig servletConfig;
    protected Collection<V3Listener> listeners = null;

    public ModuleApplicationContext(String packagePath, Resource[] resource, V3Context v3Context) throws IOException {
        super(v3Context.getApplicationContext());
        ApplicationContext applicationContext = v3Context.getApplicationContext();
        if (applicationContext instanceof WebApplicationContext) {
            this.servletContext = ((WebApplicationContext)applicationContext).getServletContext();
        } else {
            this.logger.warn("v3Context 不是有效的WebApplicationContext，标识当前运行在非web环境下，某些程序将无法正确运行。");
        }

        if (resource != null && resource.length != 0) {
            this.v3Context = v3Context;
            this.resource = resource;
		//......
    }
    //......    
    protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
        XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);
        beanDefinitionReader.setEnvironment(this.getEnvironment());
        beanDefinitionReader.setResourceLoader(this);
        beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));
        beanDefinitionReader.loadBeanDefinitions(this.resource);
    }      
    //......        
}
```

各个spring容器创建完成后，还需要全部初始化一遍，将各个模块的bean配置加载到各自的容器中，这个触发点就是：

```java
//org.springframework.context.support.AbstractRefreshableConfigApplicationContext#afterPropertiesSet
moduleApplicationContext.afterPropertiesSet();
```

### 1.事件监听功能

使用V3ContextAware接口获取到V3ApplicationContextLoader对象，发布一个事件，会有对应的监听器来处理当前事件

```java
//v3Context为注入的V3ApplicationContextLoader对象
this.v3Context.publishEvent(new FuncEvent(this, FuncCode.LOGIN, userId));
//发送用户事件到MQ(登录)
this.v3Context.publishEvent(new CampusUserEvent(this, 0, userId, CampusUserEventSource.LOGIN, new Date()));
```

处理逻辑

```java
//V3ApplicationContextLoader
public void publishEvent(V3Event event) {
    Iterator var2 = this.v3Listeners.iterator();

    while(var2.hasNext()) {
        V3Listener listener = (V3Listener)var2.next();
        listener.onV3Event(event);
    }

    var2 = this.getModuleContext().iterator();

    while(var2.hasNext()) {
        ModuleContext moduleContext = (ModuleContext)var2.next();
        moduleContext.publishEvent(event);
    }

}
```

对应V3Listener对象的如下：

```java
public class CampusUserEventListener implements V3Listener {
    protected transient Logger logger = LoggerFactory
            .getLogger(this.getClass());
    private static Executor sendMqCampusEventExecutor = DefaultExecutorServiceWapper.create()
            .poolName(ThreadPoolNameConstant.PN_SEND_MQ_USER_EVENT_POOL)
            .threadNamePrefix(ThreadPoolNameConstant.PREFIX_SEND_MQ_USER_EVENT)
            .corePoolSize(100)
            .buildCustomThreadPool();
    private CampusEventProducer campusEventProducer;
    private CampusPreferenceUtils preferenceUtils;
    private CpUserManager cpUserManager;

    @Override
    public void onV3Event(V3Event v3Event) {
        //....
    }
    
}
```

### 

### 2.统一业务处理功能

直接通过请求参数决定访问那个业务处理类

```java
//具体业务处理类
public class PayGatewayNewProcess50 extends BaseMessageProcess {

    @Override
    public String getCommand() {
        //返回当前业务公测
        return PayGatewayNewCommand50.SERVICE;
    }

    @Override
    public BaseRequestCommand createRequestCommand(JSONObject jsonData) {
        //返回po转变类型
        return this.createRequestCommand(jsonData, PayGatewayNewCommand50.class);
    }


    @Override
    public String process(SessionInfo sessionInfo, BaseRequestCommand baseRequestCommand) {
        //具体业务处理...
    }
}
//抽象父类实现了MessageProcess接口
public abstract class BaseMessageProcess implements MessageProcess {...}
```

调用方式

```java
//messageProcessCenter对象由spring注入，默认实现类是DefaultMessageProcessCenter
//这个方法会根据参数路由到MessageProcess接口对象，执行process方法
resultJson = this.messageProcessCenter.processRequestMessage(sessionInfo, requestJsonData,this.getRequest());
```

实现逻辑：
有一个业务中心管理对象DefaultMessageProcessCenter，这个对象管理所有的MessageProcess接口对象

```java
public class DefaultMessageProcessCenter extends BeanSearch<MessageProcess>
    
public abstract class BeanSearch<T> implements InitializingBean, V3ContextAware, ModuleContextAware, V3BeanPostProcessor 
```

这个对象在实例化时会执行afterPropertiesSet()方法，扫描全部的MessageProcess接口对象，并存储起来

```java
//BeanSearch.afterPropertiesSet()
public void afterPropertiesSet() throws Exception {
    //获取MessageProcess接口class信息
    if (this.interfaceClass == null) {
        this.interfaceClass = (Class)((ParameterizedType)this.getClass().getGenericSuperclass()).getActualTypeArguments()[0];
    }

    if (this.getScope() == BeanSearch.Scope.MODULE) {
        String destModule = this.moduleContext.getModuleId();
        if (this.logger.isDebugEnabled()) {
            this.logger.debug("模块内部对象搜索：" + this.interfaceClass);
        }
		//寻找注册MessageProcess接口对象
        this.findBean(this.moduleContext.getApplicationContext(), destModule, destModule);
    }

}

//BeanSearch.findBean()
private void findBean(ApplicationContext applicationContext, String sourceModule, String destModule) {
    //获取ioc中MessageProcess接口对象
    Map<String, T> beans = applicationContext.getBeansOfType(this.interfaceClass);

    if (beans != null && beans.size() > 0) {
        Iterator var5 = beans.values().iterator();

        while(var5.hasNext()) {
            T bean = var5.next();
            //子类实现(具体由DefaultMessageProcessCenter实现)
            this.regeditBean(bean);
        }
    }
}

//DefaultMessageProcessCenter.regeditBean()
@Override
protected void regeditBean(MessageProcess messageProcess) {
    //通过业务对象的getCommand方法获取key
    final String command = messageProcess.getCommand();
    this.logger.debug("******messageProcess*******" + command);
    //将当前bena实例作为val存储到map中
    messageProcesss.put(command, messageProcess);
}
```

当业务方法调用时，会触发DefaultMessageProcessCenter.processRequestMessage()方法的执行

```java
@Override
public String processRequestMessage(SessionInfo sessionInfo, String jsondata, HttpServletRequest request) {
    //主要逻辑如下
    JSONObject json = JSONObject.parseObject(jsondata);
    String command = json.getString("service");
    //根据key拿到MessageProcess接口实例
    MessageProcess process = messageProcesss.get(command);
    
    //json转换为po
    BaseRequestCommand commandObject = process.createRequestCommand(json);
   
    //业务执行
    String result = process.process(sessionInfo, commandObject);
    
    //其他处理...
}
```

其他对象只要注入DefaultMessageProcessCenter对象，根据command标记获取process实例，再调用实例的process.process方法就行了。

请求方式：

需要当前还存活的session信息字段：token和workKey，这两个端可以从redis中获取：根据前缀CAMPUS:springRedis:sessionInfo:*到redis中查询具体的存活session梳理如下：

![image-20211014174928580](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora-wm/202110141749514.png)

其中的id就是完美校园的token，workKey是请求数据的加/解密key

```java
	String token = "993957f1-7c93-4f58-b208-ab14d01bac71";
	String workKey = "779db27858b041dda68e07fb7ae5adea";

	//配置参数
	JSONObject reqData = new JSONObject();
	reqData.put("userid", "203");
	reqData.put("versionname", "WeChat-WanXiao");
	reqData.put("versioncode", "1");
	reqData.put("telphonemodel", "WeChat-WanXiao");
	reqData.put("telphoneinfo", "WeChat-WanXiao");
	//公众号旧支付接口
	//reqData.put("service", "WX0008");
	//公众号新支付接口
	reqData.put("service", "WX_NEW_0008");
	
	//实际入参
	JSONObject body = new JSONObject();
	body.put("gateway_id", 229);
	body.put("gateway_type", "publicndwxpay");
	body.put("opfare", "1");
	body.put("type", "1");
	reqData.put("data", body);
	System.out.println(reqData);
	
	//加密
	byte[] resultData = ANSI99MacUtils.tEncryptDES(workKey.getBytes("UTF-8"), reqData.toString().getBytes("UTF-8"));
	String encryData = new String(Base64.encodeBase64(resultData), "UTF-8");

	JSONObject reqJson = new JSONObject();
	reqJson.put("session", token);
	reqJson.put("data", encryData);
	String res = HttpRequestUtils.sendHttpRequestJson("http://localhost:8091/campus/service_iface/servicenew.action", reqJson.toString());
System.out.println(res);
```


​		

### 3.加密方式

- 加密方式1：3des加密

  ```java
  //key, signCalType为配置参数
  String reqSign = Pboc3desmac.sign(requestDataOrder, key, signCalType);
  requestDataOrder.put("sign", reqSign);
  ```

- 方式2：rsa加密

  ```java
  String resultDataStr = RSAUtil.encryptByPublicKey(resultjson,
          sessionInfo.getPublickey());//用公钥加了个密
  ```

- 方式3：des加密

  ```java
  //加密
  DesUtil.encrypt(wmslParamJSON.toString(), "0", encryptKey)
  //解密
  DesUtil.decrypt(data, cloudSignProp.getString("desKey"))
  ```

### 4.多数据源

对数据表的操作对象层如下所示：

Action--->Manager(ManagerImpl)--->Dao(DaoImpl)--->hibernateTemplate(不同类型的Dao持有不同连接的session对象)

所以我们可以创建多个不同数据库连接的hibernateTemplate对象，将他们注入到Dao中作为操作sql的主体对象即可，实例如下：

- 设置一个连接池对象

  ```xml
  <bean id="logDB_dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close">
      <!-- 基本属性 url、user、password -->
      <property name="driverClassName" value="${jdbc.log.m.driverClassName}"/>
      <property name="url" value="${jdbc.log.m.url}"/>
      <property name="username" value="${jdbc.log.m.username}"/>
      <property name="password" value="${jdbc.log.m.password}"/>
      <!-- 配置初始化大小、最小、最大 -->
      <property name="initialSize" value="5"/>
      <property name="minIdle" value="10"/>
      <property name="maxActive" value="60"/>
      <!-- 配置获取连接等待超时的时间 -->
      <property name="maxWait" value="60000"/>
      <!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 -->
      <property name="timeBetweenEvictionRunsMillis" value="60000"/>
      <!-- 配置一个连接在池中最小生存的时间，单位是毫秒 -->
      <property name="minEvictableIdleTimeMillis" value="300000"/>
      <property name="validationQuery" value="SELECT 'x'"/>
      <property name="testWhileIdle" value="true"/>
      <property name="testOnBorrow" value="false"/>
      <property name="testOnReturn" value="false"/>
      <!-- 打开PSCache，并且指定每个连接上PSCache的大小 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。-->
      <property name="poolPreparedStatements" value="false"/>
      <!--要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100-->
      <property name="maxPoolPreparedStatementPerConnectionSize" value="-1"/>
      <!-- 配置监控统计拦截的filters，去掉后监控界面sql无法统计 -->
      <property name="filters" value="stat"/>
      <!--配置removeAbandoned对性能会有一些影响，建议怀疑存在泄漏之后再打开。在上面的配置中，如果连接超过30分钟未关闭，就会被强行回收，并且日志记录连接申请时的调用堆栈。-->
      <property name="removeAbandoned" value="true"/> <!-- 打开removeAbandoned功能 -->
      <property name="removeAbandonedTimeout" value="300"/> <!-- 300秒，也就是5分钟 -->
      <property name="logAbandoned" value="true"/> <!-- 关闭abanded连接时输出错误日志 -->
  </bean>
  ```

- 利用连接池创建session对象

  ```xml
  <bean id="logDB_sessionFactory"
        class="net.newcapec.campus.server.plugin.CampusLogAnnotationSessionFactoryBean">
    <!-- 设置要扫描的po路径-->  
      <property name="packagesToScan">
          <list>
              <value>net.newcapec.campus.server.entityLog</value>
          </list>
      </property>
      <!-- 设置连接池对象-->  
      <property name="dataSource" ref="logDB_dataSource"/>
      <!-- 设置hibernate相关配置-->  
      <property name="propertieLocation" value="classpath:hibernate.config.properties"/>
  </bean>
  ```

- 创建方言格式对象和session对象(hibernateTemplet)

  ```xml
  <bean id="logDB_dialectManager" class="net.newcapec.v3.plugin.hibernate.DialectManagerImpl"
        p:sessionFactoryProxy-ref="logDB_sessionFactory"/>
  
  <!-- 将sessionFactory、dialectManager两个对象封装到抽象类AbstractHibernateTemplet中，该类不会被实例化，但可以作为其他bean的父bean，用来将这个两个对象通过set方法注入到子bean中--> 
  <bean id="logDB_hibernateTemplet" abstract="true"
            class="net.newcapec.campus.server.plugin.AbstractHibernateTemplet"
            p:sessionFactory-ref="logDB_sessionFactory"
            p:dialectManager-ref="logDB_dialectManager"/>
  ```

- Dao对象使用parent属性来将AbstractHibernateTemplet类中的CampusLogAnnotationSessionFactoryBean注入到Dao对象中

  ```xml
  <bean id="userappCFGLogDao"
        class="net.newcapec.campus.server.dao.impl.UserappCFGLogDaoImpl"
        parent="logDB_hibernateTemplet"/>
  ```

我们来具体了解下parent父bean是如何将sessionFactory、dialectManager注入到子bean的。先看下子bean的类：

```java
public class UserappCFGLogDaoImpl extends HibernateBaseDaoImpl<UserappCFGLog> implements UserappCFGLogDao{
}

//重点显然在父类中（下面简单截取一部分父类代码）
@Repository
public abstract class HibernateBaseDaoImpl<T extends Serializable> extends HibernateDaoSupport implements BaseDao<T>, V3InitializingBean {
    protected final transient Logger logger = LoggerFactory.getLogger(this.getClass());
    private JdbcTemplate jdbcTemplate;
    protected DialectManager dialectManager = null;
    protected final Class<T> persistentClass = (Class)((ParameterizedType)this.getClass().getGenericSuperclass()).getActualTypeArguments()[0];
    public static final HibernateBaseDaoImpl.NotBlankPropertySelector NOT_BLANK = new HibernateBaseDaoImpl.NotBlankPropertySelector();

    public T save(T entity) {
        Assert.notNull(entity);
        this.getHibernateTemplate().save(entity);
        return entity;
    }
    
        public T update(T entity) {
        Assert.notNull(entity);
        this.getHibernateTemplate().update(entity);
        return entity;
    }

    public T merge(T entity) {
        Assert.notNull(entity);
        return (Serializable)this.getHibernateTemplate().merge(entity);
    }

    public void delete(T entity) {
        Assert.notNull(entity);
        this.getHibernateTemplate().delete(entity);
    }
}
```

通过上述代码逻辑可以发现，多数sql操作放法是通过this.getHibernateTemplate()获取HibernateTemplate对象来进行的，而这个对象是在更上一层的父类中的：

```java
public abstract class HibernateDaoSupport extends DaoSupport {
    private HibernateTemplate hibernateTemplate;

    public HibernateDaoSupport() {
    }

    //创建hibernateTemplate对象
    public final void setSessionFactory(SessionFactory sessionFactory) {
        if (this.hibernateTemplate == null || sessionFactory != this.hibernateTemplate.getSessionFactory()) {
            this.hibernateTemplate = this.createHibernateTemplate(sessionFactory);
        }

    }

    protected HibernateTemplate createHibernateTemplate(SessionFactory sessionFactory) {
        return new HibernateTemplate(sessionFactory);
    }

    public final SessionFactory getSessionFactory() {
        return this.hibernateTemplate != null ? this.hibernateTemplate.getSessionFactory() : null;
    }

    public final void setHibernateTemplate(HibernateTemplate hibernateTemplate) {
        this.hibernateTemplate = hibernateTemplate;
    }

    public final HibernateTemplate getHibernateTemplate() {
        return this.hibernateTemplate;
    }

    protected final void checkDaoConfig() {
        if (this.hibernateTemplate == null) {
            throw new IllegalArgumentException("'sessionFactory' or 'hibernateTemplate' is required");
        }
    }
}
```

很显然，这个hibernateTemplate对象要么就是通过setSessionFactory()方法产生，要么就是通过set方法注入，我们回到子类HibernateBaseDaoImpl中看看哪个方法被调用了：

```java
@Resource(name = "dialectManager")
public void setDialectManager(DialectManager dialectManager) {
    this.dialectManager = dialectManager;
}
//调用父类setSessionFactory创建新hibernateTemplate对象
@Resource(name = "sessionFactory")
public void setHibernateSessionFactory(SessionFactory sessionFactory) {
    super.setSessionFactory(sessionFactory);
}
```

这两个set方法就会通过bean parent属性来将AbstractHibernateTemplet类中的dialectManager、sessionFactory两个对象注入进来，再重新创建一个hibernateTemplate来操作sql。

总结：通过创建不同连接的logDB_hibernateTemplet对象，并将之设置为Dao对象的parent属性(父bean)，让Dao对象通过set方法获取到父bean中的sessionFactory、dialectManager，这样就可以创建不同数据库的操作对象了。

### 5.通过set方法注入子类

有一些通用类使用了父类和泛型，在实际使用中会注入子类实例，或向下转型来进行使用，例如：

```java
public class BaseManagerImpl<T extends Serializable> implements BaseManager<T>, InitializingBean {
    protected final transient Logger logger = LoggerFactory.getLogger(this.getClass());
    protected BaseDao<T> dao;

    public BaseManagerImpl() {
    }

    //通过直接在set方法上使用@Resource进行属性注入，这里通常注入的是入参的子类实例
    @Resource
    public void setDao(BaseDao<T> dao) {
        this.dao = dao;
    }
    
    //。。。。。。
}
```

注入关系xml如下：

```xml
<bean id="cpNatureUserInformationManager" parent="transactionProxy">
    <property name="target">
        //dao-ref就是setDao的设置入参
        <bean class="net.newcapec.campus.server.manager.impl.CpNatureUserInformationManagerImpl"
              p:dao-ref="cpNatureUserInformationDao">
        </bean>
    </property>
</bean>
```

### 6.maven构建war

```xml
<build>
    //构建目标文件名称后缀(默认是${project.artifactId}-${project.version})
    <finalName>${project.artifactId}</finalName>
    //build对应的maven命令(这里是mvn package)
    <defaultGoal>package</defaultGoal>
    
    //此外还有directory标签，指定目标build文件输出位置：默认是${basedir}/target目录
    
    //用来包含或排除某些文件
    <resources>
        
        <resource>
            <directory>src/main/resources</directory>
            <filtering>true</filtering>
            <includes>
                <include>META-INF/v3.xml</include>
            </includes>
        </resource>
        <resource>
            <directory>src/main/resources</directory>
            <filtering>false</filtering>
            <excludes>
                <exclude>META-INF/v3.xml</exclude>
            </excludes>
        </resource>
    </resources>
    <plugins>
        <plugin>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.1</version>
            <configuration>
                <source>1.7</source>
                <target>1.7</target>
                <showWarnings>true</showWarnings>
            </configuration>
        </plugin>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-jar-plugin</artifactId>
            <version>2.3.2</version>
            <configuration>
                <classesDirectory>target/classes</classesDirectory>
                <finalName>${project.artifactId}-${project.version}</finalName>
                <outputDirectory>target</outputDirectory>
                <!--<encoding>UTF-8</encoding>-->
            </configuration>
            <!--<executions>
                <execution>
                    <phase>package</phase>
                    <goals>
                        <goal>jar</goal>
                    </goals>
                    <configuration>
                        <classifier>v3</classifier>
                    </configuration>
                </execution>
            </executions>-->
        </plugin>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-war-plugin</artifactId>
            <version>2.4</version>
            <configuration>
                <!-- 释放将项目的类文件打成jar放到lib目录中。 打成jar的好处是：只修改class时，可以只更新jar。 -->
                <archiveClasses>true</archiveClasses>
                <webResources>
                    <resource><!-- 打包，打入V3的web工程公共配置文件 -->
                        <directory>src/main/config</directory>
                        <targetPath>WEB-INF/classes</targetPath>
                        <filtering>true</filtering>
                    </resource>
                </webResources>
            </configuration>
        </plugin>
        <plugin>
            <groupId>org.apache.tomcat.maven</groupId>
            <artifactId>tomcat7-maven-plugin</artifactId>
            <version>2.2</version>
            <configuration>
                <path>/</path>
                <port>8080</port>
                <uriEncoding>UTF-8</uriEncoding>
            </configuration>
        </plugin>

        <plugin>
            <groupId>org.mortbay.jetty</groupId>
            <artifactId>maven-jetty-plugin</artifactId>
            <version>6.1.26</version>
            <configuration>
                <!-- 增加systemProperties属性 -->
                <systemProperties>
                    <systemProperty>
                        <name>org.mortbay.jetty.Request.maxFormContentSize</name>
                        <!-- -1代表不作限制 -->
                        <value>-1</value>
                    </systemProperty>
                </systemProperties>

                <scanIntervalSeconds>0</scanIntervalSeconds>
                <contextPath>/campus</contextPath>
                <connectors>
                    <connector implementation="org.mortbay.jetty.nio.SelectChannelConnector">
                        <port>8090</port>
                    </connector>
                    <!--<connector implementation="org.mortbay.jetty.security.SslSocketConnector">
                        <port>443</port>
                        <keystore>${project.basedir}/localhost.keystore</keystore>
                        <password>12345678</password>
                        <keyPassword>12345678</keyPassword>
                    </connector>-->
                </connectors>
                <webDefaultXml>webdefault.xml</webDefaultXml>
                <reload>manual</reload>
            </configuration>
        </plugin>
    </plugins>
</build>
<packaging>war</packaging>
```

### 7.ORM对象使用redis缓存

参见net.newcapec.campus.server.dao.impl.CustomerDaoImpl，该类是Customer类的Dao层对象，除了使用hibernate进行数据库查询外，还使用了redis进行对象缓存，方便下次查询不走数据库。



### 8.Drools规则执行器

Drools是jboss出品的一个规则执行器，最主要的功能就是可以将一些业务功能脚本写入到数据库中，这样就可以动态控制一些频繁变动的业务规则。下面就是Drools的具体的使用对象：

```java
public class DroolsManagerImpl implements V3InitializingBean, DroolsManager{
   protected final transient Logger logger = LoggerFactory.getLogger(this.getClass());
   private RuleBase ruleBase;
   //存储规则的数据表Manager对象
   @Autowire 
   private RuleManager ruleManager;

   @Override
   public void afterLoaderV3Context() throws Exception {
      init();
   }
    
   public void init() throws DroolsParserException, IOException{
      System.setProperty("drools.dateformat", "yyyy-MM-dd HH:mm:ss");
      ruleBase = RuleBaseFactory.newRuleBase();
      loadRules();
   }
   
   private void loadRules() throws DroolsParserException, IOException{
      execRules();
   }
   
   private void execRules() throws DroolsParserException, IOException{
      //全部更新为非运行状态
      ruleManager.updateAllNotRun();
      //查询全部需要执行的规则数据 
      List<Rule> ruleList=ruleManager.findByCondition(Conditions.eq("active", true),Conditions.eq("check", true));
      PackageBuilder packageBuilder = new PackageBuilder();
      for (Rule rule : ruleList) {
         StringReader reader = new StringReader(rule.getContent());
         packageBuilder.addPackageFromDrl(reader);
         reader.close();
         if(packageBuilder.hasErrors()){
            packageBuilder.undo();
         }
         //更新状态
         rule.setRun(true);
         ruleManager.update(rule);
      }
      ruleBase.addPackages(packageBuilder.getPackages());
   }
   
   /* 
    * 重新加载要执行的规则列表
    */
   @Override
   public void reloadRules() throws DroolsParserException, IOException{
      org.drools.rule.Package[] packages = ruleBase.getPackages();
      for(org.drools.rule.Package pg : packages) {
         ruleBase.removePackage(pg.getName());
      }
      loadRules();
   }
   
   
   /* 
    * 检查脚本是否存在问题
    */
   @Override
   public boolean checkRule(String content){
      boolean flag=true;
      KnowledgeBuilder kbuilder=KnowledgeBuilderFactory.newKnowledgeBuilder();
      kbuilder.add(ResourceFactory.newReaderResource(new StringReader(content)), ResourceType.DRL);
      if(kbuilder.hasErrors()){
         flag=false;
         KnowledgeBuilderErrors errors=kbuilder.getErrors();
         for (KnowledgeBuilderError error : errors) {
            logger.debug(error.toString());
         }
      }
      return flag;
   }
   
   /* 
    * 执行脚本规则1
    */
   @Override
   public List<OutVo> executeRule(FactVo factVo){
      StatelessSession session=ruleBase.newStatelessSession();
      List<OutVo>list=new ArrayList<>();
      //通过session给要执行的脚本设置初始化对象
      //out，用于存储计算结果的对象(返回为list)
      session.setGlobal("out", list);
      // cpUserManager，用于辅助业务的对象(脚本中可以写java代码，执行java对象)
      session.setGlobal("cpUserManager", cpUserManager);
      session.execute(factVo);
      return list;
   }

   /* 
    * 执行脚本规则2
    */
   @Override
   public JSONObject executeRule(AuthUserFactVo factVo) {
      StatelessSession session=ruleBase.newStatelessSession();
      JSONObject out = new JSONObject();
      //out，用于存储计算结果的对象(返回为json)
      session.setGlobal("out", out);
      session.setGlobal("cpUserManager",cpUserManager);
      session.setGlobal("customerManager",customerManager);
      //当前session会执行所有的脚本，通过factVo属性进行脚本过滤，最终只执行目标脚本
      session.execute(factVo);
      return out;
   }
    
   public  StatelessSession newStatelessSession(){
       return ruleBase.newStatelessSession();
   }
}
```

下面是一个对于DroolsManagerImpl具体应用的案例：

```java
public class SyncUserImpl extends ThirdServiceForSysManagerImpl implements SyncUser {
    @Autowire
    private DroolsManager droolsManager;
    
    public JSONObject process(){
        JSONObject result = new JSONObject();
        //从缓存字典中获取系统业务配置
        String rule = preferenceUtils.getUserAuthDataSourceRule();
        JSONObject ruleJson = JSONObject.parseObject(rule);
        String funcode = ruleJson.getString(dataSource + "SyncAuthInfo");
        if(StringUtils.isNotBlank(funcode)){
            AuthUserFactVo factVo = new AuthUserFactVo();
            factVo.setData(reqJson);
            factVo.setFuncCode(funcode);
            // 执行规则, 返回json
            result = droolsManager.executeRule(factVo);
        }
        return result;
    }
}

@Data
public class AuthUserFactVo {
	private String funcCode;
	private JSONObject data;
	private List<BaseManager> managers;

}
```

一个Drl脚本，drl脚本可以写java脚本也可以写xml脚本，Drools脚本语法可参考https://www.ytooo.top/34871.html：

```drl
//指定当前脚本是java脚本，demo是脚本包名，可自定义
package demo

//导入使用到的java对象引用
import net.newcapec.campus.server.droolsvo.AuthUserFactVo;
import net.newcapec.campus.server.manager.CpUserManager;
import net.newcapec.campus.server.manager.CustomerManager;

//全局属性，用于接收session设置的全局属性(名称一一对应)
global JSONObject out;
global CpUserManager cpUserManager;
global CustomerManager customerManager;

//脚本内容标签，后面的字符串是规则名称
rule "jfUpdateAuthInfo"
    //脚本生效时间
    date-effective "2020-4-27 0:00:00"
    //脚本过期时间
    date-expires "2099-04-28 00:00:00"
    //条件判断
	when 
		//factVo是AuthUserFactVo类的实例引用，这里是判断AuthUserFactVo实例中的funcCode是否等于jfUpdateAuthInfo
		factVo : AuthUserFactVo(funcCode == "jfUpdateAuthInfo")
	then
		Long userId = factVo.getUserId();
		CpUser cpUser = cpUserManager.get(userId);
		if(cpUser != null){
			out.put("data", cpUser);
			out.put("code_", "0");
         	 out.put("result_",true);
        	 out.put("message_","成功");
		}else{
		    out.put("code_", "1");
             out.put("result_",false);
             out.put("message_","没有查询到用户信息！");
		}
end

```

### 9.springboot多数据源

创建多数据源对象：

```java
public class DynamicDataSource extends AbstractRoutingDataSource {
    private static final ThreadLocal<String> contextHolder = new ThreadLocal<String>();

    public DynamicDataSource(DataSource defaultTargetDataSource, Map<String, DataSource> targetDataSources) {
        super.setDefaultTargetDataSource(defaultTargetDataSource);
        super.setTargetDataSources(new HashMap<Object, Object>(targetDataSources));
        super.afterPropertiesSet();
    }

    @Override
    protected Object determineCurrentLookupKey() {
        return getDataSource();
    }

    public static void setDataSource(String dataSource) {
        contextHolder.set(dataSource);
    }

    public static String getDataSource() {
        return contextHolder.get();
    }

    public static void clearDataSource() {
        contextHolder.remove();
    }

}
```

设置依赖bean配置：

```java
@Configuration
public class DynamicDataSourceConfig {
    @Bean
    @ConfigurationProperties("spring.datasource.druid.first")
    public DataSource firstDataSource() {
        DataSource dataSource = DruidDataSourceBuilder.create().build();

        return dataSource;
    }

    @Bean
    @ConfigurationProperties("spring.datasource.druid.second")
    public DataSource secondDataSource() {
        DataSource dataSource = DruidDataSourceBuilder.create().build();
        return dataSource;
    }
    
    @Bean("dynamicDataSource")
    @Primary
    public DynamicDataSource dataSource(@Autowired @Qualifier("firstDataSource") DataSource firstDataSource,
                                        @Autowired @Qualifier("shardingDataSource") DataSource shardingDataSource) 		{
        Map<String, DataSource> targetDataSources = new HashMap<>();
        targetDataSources.put(DataSourceNames.FIRST, firstDataSource);
        targetDataSources.put(DataSourceNames.SECOND, shardingDataSource);
        return new DynamicDataSource(firstDataSource, targetDataSources);
    }
}
```

设置选择数据源的切面：

```java
@Aspect
@Component
@Slf4j
public class DataSourceAspect implements Ordered {

    @Pointcut("@annotation(net.newcapec.reported.core.annotation.DataSource)")
    public void dataSourcePointCut() {

    }

    @Around("dataSourcePointCut()")
    public Object around(ProceedingJoinPoint point) throws Throwable {
        MethodSignature signature = (MethodSignature) point.getSignature();
        Method method = signature.getMethod();

        DataSource ds = method.getAnnotation(DataSource.class);
        if(ds == null){
            DynamicDataSource.setDataSource(DataSourceNames.FIRST);
            log.debug("set datasource is " + DataSourceNames.FIRST);
        }else {
            DynamicDataSource.setDataSource(ds.name());
            log.debug("set datasource is " + ds.name());
        }

        try {
            return point.proceed();
        } finally {
            DynamicDataSource.clearDataSource();
            log.debug("clean datasource");
        }
    }

    @Override
    public int getOrder() {
        return 1;
    }
}
```

切点的标记注解：

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DataSource {
    String name() default "";
}
```

具体的数据源配置：

```java
public interface DataSourceNames {
    String FIRST = "first";
    String SECOND = "second";
}
```

```yml
      second:  #数据源2
        url: jdbc:mysql://192.168.3.63:3306/reported?allowMultiQueries=true&useUnicode=true&characterEncoding=UTF-8
#        url: jdbc:mysql://rm-bp16v5sr5fyqv7kg9.mysql.rds.aliyuncs.com:3306/reported3?allowMultiQueries=true&useUnicode=true&characterEncoding=UTF-8
        #&serverTimezone=GMT%2B8&useSSL=false
        username: root
        password: root
#        username: reported2
#        password: ME83GfRD3
        initial-size: 10
        max-active: 100
        min-idle: 10
        max-wait: 60000
        pool-prepared-statements: true
        max-pool-prepared-statement-per-connection-size: 20
        time-between-eviction-runs-millis: 60000
        min-evictable-idle-time-millis: 300000
        #validation-query: SELECT 1 FROM DUAL
        test-while-idle: true
        test-on-borrow: false
        test-on-return: false
        stat-view-servlet:
          enabled: true
          url-pattern: /druid/*
          #login-username: admin
          #login-password: admin
        filter:
          stat:
            log-slow-sql: true
            slow-sql-millis: 1000
            merge-sql: true
          wall:
            config:
              multi-statement-allow: true
```

在controller层、service、manager层中使用注解：

```java
@PostMapping("/export")
@ResponseBody
@DataSource(name = DataSourceNames.SECOND)
public AjaxResult export(SchoolClockDetailVo userUpdataInfo) {
	//.
}
```

### 10.跨模块bean注入原理

继承NamespaceHandlerSupport，指定对应的xml标签解析器

```java
public class NamespaceHandler extends NamespaceHandlerSupport {
    public NamespaceHandler() {
    }

    public void init() {
        this.registerBeanDefinitionParser("v3-menuitems", new MenuitemsDefinitionParser());
        this.registerBeanDefinitionParser("v3-package", new ActionDefinitionParser());
        this.registerBeanDefinitionParser("v3-hibernate-mapping", new HibernateMappingDefinitionParser());
        this.registerBeanDefinitionParser("v3-module-preferences", new PreferencesDefinitionParser());
        this.registerBeanDefinitionParser("v3-db-init", new DBInitDefinitionParser());
        this.registerBeanDefinitionParser("v3-bean-proxy", new ModuleBeanProxyDefinitionParser());
        this.registerBeanDefinitionParser("v3-auto-proxy", new AutoBeanProxyDefinitionParser());
        this.registerBeanDefinitionParser("v3-resource-definition", new SecurityResourceDefinitionParser());
        this.registerBeanDefinitionParser("v3-cache", new V3CacheParser());
        this.registerBeanDefinitionDecorator("v3-property", new PropertyDecorator());
    }
}
```

这样配置好后，我们需要配置一个spring的xml配置规则xsd文件，这个规则文件中制定了一个标签的全部用法：

```xml-dtd
<!-- module bean proxy 模块间依赖管理定义配置 -->
<xs:element name="v3-bean-proxy">
   <xs:annotation>
      <xs:documentation>模块间依赖管理定义。</xs:documentation>
    </xs:annotation>
    <xs:complexType>
       <xs:attribute name="alias" use="required" type="xs:string">
          <xs:annotation>
             <xs:documentation>被代理Bean在当前环境中的别名。</xs:documentation>
          </xs:annotation>
       </xs:attribute>
       <xs:attribute name="module-id" use="required" type="xs:string">
          <xs:annotation>
             <xs:documentation>被依赖的模块ID</xs:documentation>
          </xs:annotation>
       </xs:attribute>
       <xs:attribute name="bean-id" use="required" type="xs:string">
          <xs:annotation>
             <xs:documentation>被依赖的模块中的bean的name</xs:documentation>
          </xs:annotation>
       </xs:attribute>
       <xs:attribute name="throw-exception-when-failed" use="optional" default="false" type="v3:boolean">
          <xs:annotation>
             <xs:documentation>搜索到多个实现是是否抛出异常，不配置该属性时为ture。</xs:documentation>
          </xs:annotation>
       </xs:attribute>
    </xs:complexType>
</xs:element>
```

配置完成后我们就可以引用这个标签了。

```
<v:v3-bean-proxy alias="antiTrashService" bean-id="antiTrashService"
                 module-id="v3-anti-trash"/>
```

在spring启动时，会依次加载这些自定义标签，然后通过标签名称匹配与之对应的解析器，如v3-bean-proxy对应ModuleBeanProxyDefinitionParser解析器，解析器一般会根据标签创建与之对应的beanDefinition：

```java
public BeanDefinition parse(Element element, ParserContext parserContext) {
    RootBeanDefinition beanDefinition = new RootBeanDefinition();
    beanDefinition.setBeanClass(ModuleBeanProxyFactoryBean.class);
    String moduleId = element.getAttribute("module-id");
    String beanId = element.getAttribute("bean-id");
    Assert.state(StringUtils.isNotBlank(moduleId), "error config:module-id是必配置项。");
    Assert.state(StringUtils.isNotBlank(beanId), "error config:bean-id是必配置项。");
    MutablePropertyValues values = new MutablePropertyValues();
    beanDefinition.setPropertyValues(values);
    String alias = element.getAttribute("alias");
    Assert.state(StringUtils.isNotBlank(alias), "error config:alias是必配置项。");
    V3Context v3Context = (V3Context)V3LoaderContext.V3_CONTEXT_THREAD_LOCAL.get();
    if (v3Context != null) {
        ModuleContext mctx = v3Context.getModuleContext(ModuleIdUtils.getModuleId(moduleId));
        if (mctx != null) {
            Object aimBean = null;

            try {
                aimBean = mctx.getBean(beanId);
            } catch (IllegalStateException var12) {
                this.logger.warn("module [" + moduleId + "] can not load, dependent bean [" + beanId + "] failed, please check module load order!", var12);
            }

            if (aimBean instanceof PublicBean) {
                values.addPropertyValue("targeBean", aimBean);
                beanDefinition.setPropertyValues(values);
                this.logger.info("now v3 module inject ***: from module:{}, from bean:{}, alise:{}", new Object[]{moduleId, beanId, alias});
            } else {
                StringBuffer message = (new StringBuffer("cannot execute v3 module bean inject, bean must implement to 'PublicBean': from module:")).append(moduleId).append(", from bean:").append(beanId).append(", to alise:").append(alias);
                parserContext.getReaderContext().error(message.toString(), element);
            }
        } else {
            StringBuffer message = (new StringBuffer("cannot execute v3 module bean inject, module [")).append(moduleId).append("] cannot loader, load level is low then this module.");
            parserContext.getReaderContext().error(message.toString(), element);
        }
    } else {
        StringBuffer message = new StringBuffer("cannot execute v3 module bean inject, cannot found 'V3Context'.");
        parserContext.getReaderContext().error(message.toString(), element);
    }
	//注册beanDefinition
    parserContext.getRegistry().registerBeanDefinition(alias, beanDefinition);
    return beanDefinition;
}
```

然后就是spring启动的老规则了，将BeanDefinition对象转化为具体的bean实例，这样也就可以在当前spring容器注入了。

spring xml中的多数标签都可以认为会注册到IOC容器中。
