java并发1-基础知识

#### 1.基础概念

**进程与线程：**

进程是操作系统资源分配和调度的基本单位，程序是指令、数据和组织方式的具体描述，而进程是程序运行后占用系统资源的具体表现。

`独立性`：每个进程独立存在，操作系统可以开启多个进程同时运行，是资源使用的基本单位。

`动态性`：进程在操作系统中的状态是可以互相转变的，并非一成不变。

`结构性`：进程是程序、数据、操作系统的进程指令构成的。

* * *

线程是代码指令执行的基本单位，又称为轻量级进程。每个进程可以开启多个线程同时工作。线程在执行指令之间会在多个状态中不断变化：

![image-20201012182410024](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20201102102144.png)

NEW：线程创建后等待启动状态

RUNNABLE：线程运行中的状态

TERMINATED：线程终止运行状态

BLOCKED：线程阻塞状态，等到获取到临界区资源后会变为RUNNABLE状态

WAITING：线程等待状态，线程通过执行wait()方法进入的状态，可设置参数变为有限有限时间内等待状态(TIMED_WAITING)，之后通过noitfy()或noitfyAll()方法唤醒线程进入RUNNABLE状态

TIMED_WAITING：有限时间内等待状态，等待时间结束后自动回到RUNNABLE状态

**同步(sync)与异步(async)：**

同步指是程序代码必须按照顺序执行，运算数据有绝对的先后顺序。异步指程序代码执行过程中，可以将部分代码交给线程2去执行，而主线程代码在启动线程2后可以继续执行后续的代码，而不用等待线程2的内容执行完成。以方法为例，同步方法的调用需要等待方法体代码执行完成后才可继续执行，异步方法的调用不需要等待方法体执行完成，可直接执行后续代码。

**并发(concurrent)与并行(parall)：**

并发和并行都是多个对象同时执行的意思。但是两者有细微的差距：并发偏指表象上的同时执行，但是实际上可以是顺序执行(伪并行)，例如单线程CPU是以极短的时间切片内，来切换执行不同进程的计算命令,但是对外的表象却是个进程同时执行。并行则指真正的同时执行，如多核多线程同时执行某个计算命令。

**临界区：**

如果多线程共同操作一个对象，则这个对象就是临界区资源。临界区指存储唯一资源(公共资源)的内存区，如果一个线程获取了某个临界区资源，则其他线程要等到上一个线程释放这个临界区资源，才能进行获取。

**阻塞(blocking)与非阻塞(non-blocking)：**

阻塞和非阻塞是线程之间互相影响产生的现象，线程占用临界区资源、休眠(sleep)、挂起(suspend)都会产生阻塞。例如一个线程占用了临界区的某个资源，在这个线程未释放这个资源前，其他线程会进入等待状态，无法继续执行，这就产生了阻塞。非阻塞和阻塞正相反，指线程执行指令无阻碍、不会陷入等待状态。

**死锁(deadlock)、活锁(livelock)与饥饿(starvation):**

三种导致线程无法继续执行指令、陷入死循环的情况。

`死锁`：两个线程各自占用一个临界区资源、在之后的指令中需要获取彼此占用的资源对象，导致一致获取不到导致的死循环。

`活锁`：两个线程正常执行，当一个线程获取到资源时，监控到对方线程对象时会主动让出资源空间、另一个线程逻辑与此相同时，则双方会一直谦让这个资源空间导致指令无法继续进行。

`饥饿`：线程之间是由优先级之分的，当优先级高的线程过多时，会导致某个优先级低的资源始终抢占不到资源空间，导致指令无法继续执行。

#### 2.并发优化级别

**悲观锁：**

线程同步执行指令，遇到临界区资源需要排队获取，获取不到的线程陷入阻塞等待状态

**无饥饿(starvation-free):**

限制线程高优先级先执行的特性，所有线程必须按照一定序列进行排队获取资源

**乐观锁:**

数据使用版本号控制一致性，修改数据前先查询版本号，使用版本号作为修改条件进行修改，修改成功则更新版本号，更新不成功则回滚，重新进行修改尝试。

```sql
update table set column = newVal, version = version+1 where id ="XXX" and version = "XXX"
```

java1.5后的CAS机制就是基于乐观锁思想实现的

#### 3.线程常用对象方法

**创建线程的常用方式：**

方式 一：继承Thread类

```java
static class Thread1 extends Thread{
    @Override
    public void run(){
        //...
    }
}

public static void main(String[] args){
    Thread t1 = new Thread1();
    t1.start();
}

```

方式二：实现Runnable接口

推荐使用！接口与Thread解耦

```java
static class Thread2 implements Runnable{
    @Override
    public void run(){
        //...
    }
}
public static void main(String[] args){
    Thread t2 = new Thread(new Thread2());
    t1.start();
}
```

**Thread中sleep()、join()与yield()：**

`sleep(...)：`线程休眠方法，执行方法会放开CPU执行权，但不会释放对象锁(会阻塞)，该方法需要设置参数指定休眠时间，时间到后会自动执行后续代码。如果想打断休眠行为唤醒线程，则可以使用interrupt()方法使线程抛出InterruptedException异常执行catch代码块，而后继续执行后续代码

`join()：`阻塞当前线程，等待目标线程执行结束后当前线程才会继续执行

`yield()：`线程谦让方法，当执行此方法时，线程(线程1)会让出CPU执行权，然后所有线程进行一次CPU资源竞争，线程1可能再次抢到CPU执行权再次继续执行，或等待下一次抢到CPU执行权的机会

**Thread中挂起suspend()与恢复resume()：**

线程挂起和恢复方法；当调用suspend()方法时会暂停当前线程的执行，但是不会释放对象锁(造成阻塞)，只有当调用resume()方法时才会恢复线程的执行。由于会造成阻塞这两个方法必须要成对出现，但是线程之间执行的效率是不同的，如果一个线程(线程1)执行suspend()另一个线程(线程2)执行resume()，有可能线程2会先执行resume()，而后执行的suspend()会造成永久的阻塞，所以这对方法在JDK中已过期

**Object中的等待wait()与唤醒notify()：**

等待和唤醒是Object类中的两个线程方法，所以所有的对象都是可以调用这两个方法的。但是这两个方法的使用有限制：必须在对象锁Synchronized中，调用锁住对象的wait()或notify()才起作用。

在同步块(方法)中调用wait()方法时，当前线程会让出CPU执行权，也会释放同步对象锁(不会造成阻塞)；当另一个线程调用锁住对象的notify()时，会**随机**唤醒一个执行过锁住对象的wait()的线程，此时需要等到notify()所在同步块(方法)执行完成后释放了对象锁，才会继续回到被唤醒线程执行wait()方法后的代码

除了notify()方法外，还有一个notifyAll()方法，可以唤醒所有执行过锁住对象的wait()的线程

```
思考：挂起/唤醒会有唤醒方法先执行，后执行挂起导致所有线程锁死的情况；虽然wait()方法会放同步锁，但是也会造成当前线程的锁死，那么如何处理先执行notify()后执行wait()方法造成的问题？答案见参考链接
```

总结：sleep()时不会释放当前锁对象，也是sleep期间其他线程来获取当前对象时会被阻塞。wait()时只会阻塞当前线程，对其他线程无影响。

**Thread中的停止stop()和中断interrupt()：**

`stop()：`线程终止方法，执行此方法会立即停止线程的执行，由于该方式过于粗暴直接，会造成逻辑异常、脏数据产生等问题，所以已废弃为过期方法

`interrupt()：`线程中断方法，和stop()方法不同interrupt()不会立即终止线程的执行，而是给线程设置一个中断标记，线程在之后会继续执行，但是在执行代码时会进行中断标记轮询检测，在遇到特定代码时会响应这个中断标记抛出InterruptedException异常，我们可以忽略这个异常继续执行代码或是直接结束线程的执行。

Thread还提供了两个判断线程是否中断的方法：

```java
//判断当前线程是否已中断(存在中断标记)
public boolean isInterrupted();
//判断当前线程是否已中断，并会清除中断标记
public boolean interrupted();
```

例如：线程执行interrupt()方法后遇到sleep()、wait()等throws过InterruptedException方法时，会执行对应的catch方法块，此时我们可以中断线程执行，或是忽略异常继续执行。

```
注意：抛出InterruptedException后中断标记会被清除
```

中断参考：https://www.cnblogs.com/wxgblogs/p/5416788.html

中断休眠参考：https://blog.csdn.net/weixin_41101173/article/details/79889464

等待唤醒参考：https://blog.csdn.net/wangquan1992/article/details/103720589

https://blog.csdn.net/tayanxunhua/article/details/20528475