## TCP连接相关解析

![image-20220905160235766](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora-wm/202209051602121.png)

### 什么是TCP连接？

TCP是传输层的一种数据通信协议，特点是**面向连接、可靠的、基于字节流的**，具体可以这么理解：

- 面向连接，指一对一的数据传输通信，没有一对多的广播功能
- 可靠性，基于连接tCP连接四元组，序列号、滑动窗口等机制保证每个报文的成功传输
- 基于字节流，指传输的数据大小是没有限制的，可以像水流一样远远不断

使用TCP协议构建的连接就是客户端与服务端之间进行数据通信的基础，即让两端创建出一个独立、相对隔离、稳定的数据传输环境。

**如何确定一个TCP连接呢？**

答案是通过TCP的四元组来确定，四元组包括客户端的ip、使用端口和服务端的ip和访问端口。

![image-20220905161001811](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora-wm/202209051610854.png)

**TCP连接服务端某进程的最大连接数是多少？**

这种情况下，目标地址和端口是确定的，客户端的ip地址和端口是不确定的，由于ip地址数最多为2^32次方，端口受类型限制最大为2^16次方，所以服务器单机进程的理论最大TCP连接约为2^48次方，当然实际上并不会让服务器的并发连接达到这个地步，而且每个TCP连接受物理内存大小限制和操作系统文件句柄文件数的限制。

**TCP连接某服务端的最大连接数是多少？**

端口受类型限制最大为2^16次方，加上此情况下目标地址和端口是确定的，源ip地址也是确定的，只有端口不确定，所以单客户端对同一个服务最大只能发起65535个TCP连接。

**TCP和UDP的区别与应用场景？**

TCP相比于UDP而言，是端对端、可靠、有序、无差错的流式传输协议，但是因为有拥塞控制、流量控制、首部数据存储等要求，所以数据大小等开销会多一些。常用于http、ftp等需要保证数据可靠交付的面向连接场景中。

UDP相比于TCP而言，是多端对多端、相对不可靠、无序、尽最大努力交付数据的一个个数据包传输协议，由于没有TCP为保证数据可靠、有序等诸多要求，所以UDP有传输速率比TCP高，首部开销也比TCP小等特点，常用于音视频等多媒体通信、直播广播等通信中。

### 三次握手

TCP是面向连接的协议，所以建立连接需要通过三次握手来完成。

![image-20220905180414984](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora-wm/202209051804026.png)

上图是客户端和服务端三次握手的过程：

- 首选客户端和服务端都处于关闭状态，之后服务端开启进程服务监听端口请求。客户端发起第一个SYN报文，先随机初始化一个client_isn序列号置于TCP首部的序列号位置中，同时将SYN标志位置1代表本报文是SYN报文，之后将报文发给服务端，客户端会进入SYN_SENT状态。
- 服务端收到SYN报文后会回应一个SYN_ACK报文，同样先随机初始化一个server_isn序列号置于TCP首部的序列号位置中，然后将收到的SYN报文中的client_isn序列号+1置于确认应答号位置上，并将SYN标志和ACK标志位置1，完成后将SYN_ACK报文发给客户端，此时服务端进入SYN_RCVD状。
- 客户端收到ACK报文后核对确认应答号位上的序列号是否正常，如果正常代表服务端可以正常接收和发送数据报文。此时客户端还需要向服务端发送一个ACK回应报文，让服务端知道客户端也可以正常接收数据，按照之前的操作，将ACK标记位置1，同时将收到的SYN_ACK报文中的server_isn序列号+1置于确认应答号位置上，最后发送报文，客户端之后进入ESTABLISHED连接状态。
- 服务端收到ACK报文后确认server_isn序列号是正常增加无误后，也进入ESTABLISHED连接状态，等待http一类的数据请求。

**为什么需要三次握手呢？**

简单的说三次握手是客户端和服务端都确认了双方可以正常收发数据的最低次数要求，复杂一点来说，三次握手才能保证双方构建一个相对独立、同步的传输环境，序列号的递增校验保证本次连接一定是本次发送接收的。

### 四次挥手

断开TCP连接需要进行4次挥手来保证本次连接的结束确定性，需要注意的是客户端和服务端双方都可以主动断开连接，但是一般都是客户端主动断开的。

![image-20220906095814406](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora-wm/202209060958533.png)

上图是TCP连接四次挥手断开连接示意图：

- 首先由客户端首先发起FIN报文，报文中的FIN标记会被置1，之后客户端进入FIN_WAIT_1状态，该状态还可以继续接收数据。
- 服务端收到FIN报文后，会回复一个ACK标记置1的ACK报文给客户端，之后服务端进入CLOSE_WAIT状态，该状态是用来处理之前请求没有处理完成的计算数据的。如果服务端存在请求数据流没关闭的话，那么这个状态会一直存在，占用着端口和内存资源。
- 等待服务端处理完数据后，服务端也会向客户端再发生一个FIN报文，之后服务端进入LAST_ACK状态
- 客户端收到服务端FIN报文后，会会回应一个ACK报文给服务端，之后进入2MSL(MSL是报文最大存活时间单位，一般windows默认时间是2min，linux一般是60s)时间的TIME_WAIT状态，等待2MSL的时间后客户端完成本次连接的关闭。
- 服务端收到ACK报文后，也会完成本次连接的关闭。

**为什么需要四次挥手呢？**

四次挥手相比于三次握手，服务端多了一个等待CLOSE_WAIT状态时间后再次发生FIN报文给客户端，该状态过程是不可缺少的，因为在客户端第一次发生FIN报文给服务端后，此时服务端虽然收到了FIN报文，并且也回应了ACK报文，但是服务端可能有还未计算完成回应给客户端的数据，所以需要等待服务端将客户端的请求数据都响应后，才会再次发送FIN报文给客户端结束本次连接。

当然如果服务端没有CLOSE_WAIT状态需要处理的数据，那么会立即发送ACK报文和FIN报文，几乎可以认为也是三次挥手过程。

**为什么TIME_WAIT等待时间是2MSL？**

连接中可能还有数据包要发送和接收，一来一回需要两个单位的报文存活时间；比如客户端响应服务端的ACK报文没有被接收到，那么服务端就会重发FIN报文，客户端收到FIN后也会重发ACK报文，这样保证这两次报文发送的最大时间就是2MSL。

**为什么需要TIME_WAIT和CLOSE_WAIT状态？**

TIME_WAIT是作为客户端发起请求才会出现的状态，CLOSE_WAIT是作为服务端被访问才会出现的状态。

需要TIME_WAIT的必要原因有两点：

- 一是帮助服务端可以正确被关闭（如果客户端最后一次ACK报文没有有效的发送到位，没有停留在TIME_WAIT状态，而是直接关闭了，那么这种情况服务端TCP状态会一直停留在LAST_ACK状态占用着端口和内存资源）
- 二是让本次连接中的所有报文数据都在2MSL过程中自然关闭或丢弃（如果在连接中某个报文因为延时等问题没有有效的被发送，那么等待2MSL的时间，这些报文也会被丢弃。下次构建相同端口TCP连接肯定不会影响被上次连接的报文扰乱）

**TIME_WAIT和CLOSE_WAIT状态的危害与优化？**

服务器出现TIME_WAIT状态，一般是服务器⽅请求其他系统服务后主动发起的断开请求后停留的状态，由于服务器请求可用的端口一般在32768～61000区间中，如果TIME_WAIT状态的连接过多被占满，则会导致无法创建新的连接。

服务器出现CLOSE_WAIT状态，一般是服务端方处理请求的代码写的有问题了，一般是没有关闭请求数据流对象导致，服务端认为当前TCP连接一直没有处理完本次连接，就会一直保持在CLOSE_WAIT状态。此外如果客户端请求设置了等待服务器端响应超时的时间的话，如果服务端超时时间内还没有正常返回，那么客户端也会发起四次挥手的报文请求，但是服务端还没有处理完本次请求就会一直停留在CLOSE_WAIT状态，直到处理完为止。

优化方式：在/etc/sysctl.conf配置文件中增加如下tcp连接配置

```sh
##表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN 攻击，默认为0，表示关闭；
net.ipv4.tcp_syncookies = 1 
##表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
net.ipv4.tcp_tw_reuse = 1
## 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；
net.ipv4.tcp_tw_recycle = 1
##修改系統默认的 TIMEOUT 时间
net.ipv4.tcp_fin_timeout = 30
##表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。
net.ipv4.tcp_keepalive_time = 1200
##设置用于向外连接的端口范围
net.ipv4.ip_local_port_range = 10000 65000
##表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数
net.ipv4.tcp_max_syn_backlog = 8192
##表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。默 认为180000，改为5000
net.ipv4.tcp_max_tw_buckets = 5000
```



### TCP常见问题与解决

查询服务器tcp状态统计数据

```
netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
```



![image-20220902175406602](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora-wm/202209021754249.png)

### 为什么一台机器几百个  CLOSE_WAIT  就导致不可继续访问？

因为应用进程一般可用线程就几百到一两千左右，进程可用线程被状态为CLOSE_WAIT的TCP连接占完了，就无法接收新的TCP请求连接了。

### 输入网址回车的过程中发生了什么

- 域名根据DNS服务器解析出目标地址IP和端口
- 根据目标地址IP和端口构建TCP连接
- 完成get、post请求数据交互
- 断开TCP连接完成请求

### 生产问题排查

使用tcpdump导出tcp报文日志pcap文件，然后使用Wireshark工具查看分析

### 为什么抓到的 TCP 挥⼿是三次，⽽不是书上说的四次？

有些TCP连接中，服务端几乎没有CLOSE_WAIT的时间，所以会把给客户端发送的ACK报文和FIN报文合并发送，通常情况下一般还会是4次挥手的情况比较多，比如：

![image-20220906172944980](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora-wm/202209061729022.png)

参考：

[服务器出现大量close_wait，我们来说说到底是怎么回事？（以tomcat为例） - 三国梦回 - 博客园 (cnblogs.com)](https://www.cnblogs.com/grey-wolf/p/10936657.html)
