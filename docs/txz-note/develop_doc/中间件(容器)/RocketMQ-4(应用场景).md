### MQ的主要两种消费模式

- 集群消费：单个生产者，多个消费者，如果生产者发送10条信息到MQ，那么会由多个消费者均分这10条信息
- 广播模式消费：单个生产者，多个消费者，如果生产者发送10条信息到MQ，那么这多个消费者，每个服务都会收到10条信息

消费过程中的推拉问题：

- 使用DefaultMQPushConsumer创建消费者对象，那么Broker会主动将信息推送给消费者
- 使用DefaultMQPullConsumer创建消费者对象，那么消费者会主动的拉取信息

至于推拉的选择需要看具体的业务场景了

参考:https://www.cnblogs.com/wzh2010/p/16631097.html

### MQ的主要几种发送模式

- **同步发送：** 整个过程业务是阻塞等待的，消息发送之后等待 Broker 响应，得到响应结果之后再传递给业务线程。
- **异步发送：** 调用RocketMQ 的 Async API，消息生产者只要把消息发送任务放进线程池就返回给业务线程。所有的逻辑处理、IO操作、网络请求 都由线程池处理，处理完成之后，调用业务程序定义好的回调函数来告知业务最终的结果。
- **OneWay（单向）发送：** 只负责触发对消息的发送，发送出即完成任务，不需要对发送的状态、结果负责。
- **延迟发送：** 指定延迟的时间，在延迟时间到达之后再进行消息的发送。
- **批量发送：** 对于同类型、同特征的消息，可以聚合进行批量发送，减少MQ的连接发送次数，能够显著提升性能。
  参考：https://www.cnblogs.com/wzh2010/p/16629876.html

### MQ是如何存储消息的

我们已经知道broker是存储消息的主体容器了，但是发生一条信息到MQ，这条信息是怎么存储的？不同Topic之间的信息是如何隔离的？这些信息又是怎么做冗余备份的呢？下面我们就来了解下。

首先我们在MQ中创建Topic时，需要指定一个MessageQueue参数，这个参数的作用是这个Topic要创建几个MessageQueue，而MessageQueue的意义就是数据分片，也就是我们往MQ的Topic发送信息时，这条数据会存储到Broker中的Topic的一个分片中；也就是说broker中存储信息的数据结构是数据分片，而一个Topic的多个数据分片会分布式存储在不同的Broker中。

![image-20230317113040924](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora-wm/202303171130164.png)

如果现在有一个生产者，发送了20条数据到MQ，那么这个数据会如何存储呢？

以上图4个分片为例，生产者有可能会将这20条信息分别发送到分片1到4，每个分片5条数据。

但实际数据分配可能不会这么均匀，而是会根据不同的路由策略来发送，可能一些分片会多一些，另一些会少一些。

生产者如何知道一个Topic的所有分片信息呢？

答案是MessageQueue分片信息会随Topic信息一起注册到NameServer中，所以生产者确定发送的Topic之后，就可以获取到这个Topic的全部分片信息了。

如果某个Broker出现故障了呢？还会继续往故障Broker上的分片发送数据吗？

在RocketMQ中，Producer对象有一个开关：sendLatencyFaultEnable，如果将这个参数设置为true，那么在发送信息到MQ时，就会有一个自动容错机制，如果发送到的Broker出现了高延时、故障错误，那么在之后的一段时间内，再发送同样的信息时，则会自动回避这台Broker的访问。

