Redis面试问题

### Redis面试问题

1.Redis的线程模型是什么？为什么单线程也很高效？

1、redis内部存在一个多路复用器，用来管理多个socket，监听对应的网络事件。
2、在监听到对应的事件后，将具体将事件压入到内存队列中。
3、内存队列的消费者是一个【文件事件分派器】，就是根据不同的事件选择不同的处理器去处理。 如果是一个客户端发送请求建立连接的事件，那么就选择【连接应答处理器】建立连接并将对应socket的对应事件（AE\_READABLE）和【命令请求处理器】绑定。 接下来，如果该socket再发送对应的数据，触发事件（AE\_READABLE），同样经过分派器选择对应的处理器，比如要set就选择【命令请求处理器】从socket中读取对应的数据并操作。 最终将该socket的AE\_WRITEABLE事件跟【命令回复处理器】绑定起来。 那么最后，该客户端准备好了，可以收回复的时候，又会触发AE\_WRITEABLE事件，这个时候分派器就直接分配【命令回复处理器】，去回复客户端对应的请求。 这三个处理器，从上到下进行绑定，完成一次交互。
4、为什么说Redis是单线程的呢？因为以上那些模块都是叫做【文件事件处理器】，这组件是以单线程运行的，通过IO多路复用程序去轮训多个socket。

2.Redis数据过期策略是什么？数据淘汰机制呢？

redis的删除机制是定时删除和惰性删除两种机制的结合。
-定时删除是redis会有定时线程，定期从设置了过期时间的key里随机选择一些key并判断他们现在是否已经过期了，如果过期了就删除掉。
但是总回有一些已经过期了的key是不会被这个定时删除线程选中的，所以就有了惰性删除，
-惰性删除是，客户端在调用某个key时，如果这个key设置了过期时间，就会检查是否过期，过期了就会直接删除，没过期正常返回。

如果数据大多都是没有设置过期时间的数据，当redis的内存装满了又会怎么样处理呢？答案是会有一个处理策略设置：异步设置为allkeys-lru，即将查询次数最少的一批数据进行删除，给、空出内存来。

3.如何实现一个LRU算法？

![image-20210802102655164](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210802103028.png)

4.redis有那些数据结构，使用场景是怎样的？

string类型，存储字符串(set/get)

hash散列类型，存储对象 (hset/hget)

list列表类型，存储有序集合数据，也可以当作队列来使用(lpush/lpop=== rpush/rpop)

set列表类型，存储无序集合，可以去重(sadd/srem == scard)

sort set列表集合，存储携带分数的有序集合，用于元素去重排序，干分数截取数据等操作(zadd/zrem === 取按分数排序的前三个元素zrevrange(key,0,2))

还有一些其他类型，如GEO算坐标的，bit概率统计的

5.  redis如何处理并发线程竞争问题？
    即多个客户端对同一个key进行赋值，出现慢的客户端覆盖新客户端数据问题。
	
    处理：使用分布式锁，给请求数据加时间戳，写数据前对比时间戳是否按大小排列，如果发现时间戳小于当前数据，就不要再写入了
	
	或者使用redis的乐观锁事务watch/exec，当一个线程修改key时，如果被其他线程修改，那么这个操作就作废
	
	
	
6. redis作为分布式锁的使用？
   使用set key 随机值(val) nx ex 30命令创建一个只有在该key不存在时才能设置成功，有效时长30秒(px指有效时长为毫秒级别)
   该锁要么被删除，要么过期，其他客户端才能设置
   解锁时最好采用key+随机值双比较进行删除，为了防止某个获取锁的对象执行较慢，锁过期了每其他线程加锁了，最后这个执行满的线程把其他线程的锁给释放了。
   if redis.call('get', KEYS[1]) == 随机值 then return redis.call('del', KEYS[1]) else return 0 end
   
   ------
   
   扩展内容：使用zk作为分布式锁工具，各节点创建同一个znode锁对象节点，谁创建成功了谁就获得了锁，剩余创建失败的线程就会注册一个监听器来监听这个锁动作，当这个锁被释放时，就会通知监听的线程可以尝试获取锁了。
=========
使用场景：单系统可以使用重入锁保持线程同步，但是经过负载均衡后，多台机器就不适用于原生的java锁了，就需要一个全局的、唯一的锁来保证所有系统共用一个锁对象，者就是分布式锁。
   

   7.redis IO线程模型
   
   非阻塞IO模型在操作系统中有三种较常使用：selet、poll、epoll
   
   select和poll IO模型比较类似，都是通过在系统内核中维护一个socket集合，然后有一个线程对集合进行遍历轮询，当检查到有socket已经就绪后，就会通知用户态进程，来内核态获取数据(还需要再进行一次socket集合遍历，因为不清楚到底是集合中的那个socket就绪了)。select和poll的区别是select是由数组作为socket容器的，上限是1024个socket连接，而poll是由链表实现的，可以超过1024。
   
   而epoll则和select和poll不同，他是一种事件驱动式的IO模型，简单而言就是将socket放如一个红黑树容器中，每个
   
   socket如果就绪了就会调用一个回调事件(没有轮询了)，将socket的id写入一个链表中，同时会有线程不停的轮询(实际上会定时休息一下)这个链表，如果发现链表数据不为空就通知使用进程来这个就绪链表中读取socket的信息。(具体而言还使用mmap技术，即创建了一块内核态和用户态共用的内存空间)

8. 分布式事务？
   几种分布式事务方案：JTA、TCC、本地消息表、MQ最终一致性

![image-20210804094903415](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210804094912.png)

参考：https://zhuanlan.zhihu.com/p/98592346