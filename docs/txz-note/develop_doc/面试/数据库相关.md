数据库相关

数据库相关

1.分库分表

中间件推荐，使用sharding-jdbc或者mycat组件，区别是sharding-jdbc可以作为一个jar包直接和应用绑定，但是需要进行编码；mycat需要进行单独部署和维护，但是不需要编码。

2.垂直分表

将一个表的字段数量减少，这样每个数据页就可以存放更多的数据行

3.水平拆分

将一个表拆分到不同的库中，每个库还可以将原表拆分为多张分表；在数据分片规则上可以按照hash一致性，先对数据库数量取模确定插入那个库，再对分表数量取模确定在那个分表中。这种方式会导致扩容起来比较麻烦。
当然也可以按照时间来进行分表，比如1天一张表，1个月一张表；缺点是在某些场景下，可能只会某个时段的表的压力会很大，但是其他时间段的表却没什么流量。

```
什么时候分表？
答：单表数据上千万，读写缓慢，此时需要分表

分泌时候分库？
答：一是数据库里整体数据过多，备份时间长，占空间大；二是数据达到性能上限，需要进行
```



4.如何实施分库分表操作？
方案1，晚上停机迁移，写脚本将单库数据写入到分表中间件中，让中间件来进行数据的分库分表，完成后将生成的数据库配置改成中间件的即可。
方案2，修改生成项目所有的insert写逻辑，改造成数据双鞋，既写原单库，也写如分表中间件中，然后写一个脚本批量将单库中的数据页写入到中间件中(需要对数据进行去重判断，如果一条数据在单库和分表后都存在，那么要判断单库表数据和分表后数据的最后修改时间戳关系，如果单表中的事件靠后，那么就需要进行覆盖)，等到脚本跑过几天后，使用一些数据校验工具检验两边的数据释放完全一致，一致的话造个时间把生成连接切换为中间件的地址。

5.如何动态进行分库分表扩容？

在进行扩容时，多采用一开始就设定一个比较大的分库分表规则，这样就足够很长一段时间的使用需求。
比较靠谱的做法是一开始就按照32库 * 32表的做法，即可以拿四台数据库服务器来，每台服务器上安装好mysql，并创建8个分库，每个分库中创建32张分表，这样一共就有 32*32=1024张分表了，这样这个业务表总共有大几十亿的存储空间。

当四台服务器进入瓶颈时(达到服务器网络请求上限，磁盘存储上限等)，需要扩容，这时我们就可以只扩容数据库服务器不用扩容库和表了。
比如我们可以再找4态服务器，将之前的4台服务器中的数据库分一半，迁移到新的四台服务器上，也就成了8台服务器，每台服务器上有4个数据库，每个库里有32张分表。
按照这样做法，最高可以分到32个服务器，每个服务器只有1个数据分库，分库中有32张分表。

6.分库分表后的id如何设置？

方案1，使用一个id生成表(主键逐渐递增)，每次需要数据就插入一条数据然后取其id作为编号。

方案2，使用uuid，32位id但是比较影响性能

方案3，使用时间戳+4位递增编号，递增编号可以使用redis的incr生成，或者java的原子atomic递增获取

方案4，使用雪花算法生成，时间戳(精确到毫秒)+机房编号+服务器编号+尾数编号(从一递增，如果上一个生成的时间戳和本次生成的时间戳相同，则尾数+1)，

7.分库分表后产生的其他问题

- **join 操作** ： 同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作。这样就导致我们需要手动进行数据的封装，比如你在一个数据库中查询到一个数据之后，再根据这个数据去另外一个数据库中找对应的数据。
- **事务问题** ：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足我们的要求了。
- **分布式 id** ：分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。我们如何为不同的数据节点生成全局唯一主键呢？这个时候，我们就需要为我们的系统引入分布式 id 了。