mysql-6(数据页的物理结构)

### 数据页物理结构解析

#### 数据页

数据页的组成和数据行类似，他的主要内容是多个数据行，以及一些其他的数据页描述信息 。具体可以分为文件头 、数据页头 、最大记录/最小记录、多个数据行、空闲区域、数据页目录和文件尾几个部分组成，如下图所示：

![image-20210105074127327](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210105074135.png)

其中的文件头占38字节、数据页头占56字节、最大记录/最小记录占26字节，多个数据行、空闲区域会随着数据行的插入而不停变化，文件尾占8个字节。

当我们创建一个数据表时，就会预先创建一个空的数据页，在插入数据时会将数据页写入buffer pool内存的缓存页的多个数据行中，并且插入 后空闲区就会减少一点，随着数据行的不断插入，那么空闲区就会逐渐变小，最后全部耗尽被数据行占据，变化过程如下图所示：

![image-20210105075707669](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210105075707.png)

#### 表空间与数据区

在了解了数据页大致结构后，下面我来聊一聊之前讲buffer pool中提到的表空间、数据区等概念。

一般来说，我们经常操作的数据表就可以称之为一个个的表空间，对应在物理存储上就是一个个的.ibd文件，如下图示例：

![image-20210107104915336](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210812105632.png)

上面讲的数据页就是存储这个个表空间中，但是并不是直接放在表空间中的，毕竟一个数据页才16K，一个几百上千万数据量的表空间若直接存储数据页，那数据页的数据量也不会少，肯定是有中间存储结构存在，就跟数据行存储在数据页中一样，数据页是存储在数据区结构中的。

一个数据区能存储连续的64个数据页，那么一个数据区的大小就是16K*64=1024K=1M，这样就有一个个的数据区存在在表空间中，在此基础上，每256个数据区形成一个数据区组，数据区组才是直接存放在表空间的结构。

而在每个表空间的第一个数据组的第一个数据区的前三个数据页中，存储的是表空间、数据区等总体描述信息。大致示意图如下：

![image-20210107140120360](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210107140140.png)

#### 表数据操作回顾

到这里，我们就可以用新学到的这些结构概念，结合之前的知识点回顾一下的buffer pool总体的数据操作：

要操作一个表空间的数据，首先会根据表名找到磁盘中的.ibd文件 ，在ibd文件中按照规则选择可用数据区，取出一个或多个数据页加载到buffer pool中，之后在内存中修改/新增/删除数据页里面的数据行信息，数据页被添加到flush链后通过后台线程刷回到到表空间文件中。

![image-20210107141825151](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210107141825.png)

一般在要读取磁盘表空间数据之前，就已经确定了查询数据页的范围了，伪代码如下 ：

```java
table.setStartPoint(1);
table.setEndPoint(10);
table.read();
```

这样就可以读取到一个范围的数据页；

而数据刷盘时，会根据数据页的页码将内存中的数据页，覆盖磁盘中的数据页完成写入操作。

#### 磁盘随机读与磁盘顺序写

下面了解两个概念，一个是磁盘随机读：

当我们要查询具体的某条数据时，想要找到这条数据所在的数据页，一般只能采取IO随机读机制，这就是磁盘随机读。这个随机读主要受IOPS(磁盘随机IO读写能力)和请求延迟两个要素影响，IOPS越高代表每秒磁盘的读写次数越多，请求延迟越低代表磁盘能处理的并发请求越多。

磁盘顺序写是按照请求顺序将请求数据依次写入磁盘文件，如redo.log日志的写入就是磁盘顺序写，如果使用上OS cache机制的话，顺序写的效率其实并不比IOPS差多少。顺序写的主要影响因素是磁盘的吞吐量，即每秒能写入磁盘多少数据。

#### Linux存储系统与RAID存储架构

##### Linux存储系统

对于mysql这样的软件来说，必须要依赖操作系统来使用CPU、磁盘内存等硬件设备，而不能脱离操作系统地理存在。所以下面来简单了解下Linux系统的存储系统结构：

![image-20210108165154329](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210108165154.png)

以一条写入磁盘的mysql请求为例，这个过程主要由linux存储结构来处理的。

首先，请求到达VFS层后，会从请求中解析出要修改的磁盘文件的路径，并根据这个文件路径找到文件所属的磁盘文件系统。

请求到达第二层的文件系统后，会先去内存中查询缓存页中是否有这个目标文件数据；有，则直接读写内存中的数据、无，则将请求交给Block请求区。

在Block请求区中，主要的工作是将文件IO请求转化为磁盘Block IO请求，之后将请求交给下一层的IO调度层。

IO调度层会使用对应的Block设备驱动去磁盘中读写目标文件。

```
知识补充：
linux有几种常用的IO调度算法，根据选择不同的算法，可以有效的加快IO请求效率。
例如，如果一个请求需要长时间的使用IO读写，而排在这个请求之后的其他请求则可以极短时间的使用IO读写，那么也必须按照先来先执行的顺序进行请求处理。
如果我们将IO调度改为deadline模式，则每个线程的必须要在一个有限时间内得到执行，那么就可以提高IO的效率了。
```

##### RAID磁盘冗余阵列

在了解linux存储结构之后，下面我们来认识下一个东西：磁盘冗余阵列(RAID)，这个东西就是一个磁盘管理架构，简单的说它会告诉我们要到哪块块磁盘中处理，并且可以有效的管理磁盘的扩充、备份等问题。

![image-20210108173050734](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210108173050.png)

RAID架构可以分为RAID-0，RAID-1、RAID-10等几种架构，这里我们简单的了解下各个架构的内容和区别：

RAID-0的架构是这样的，它会把多块磁盘当做一个整体，每个磁盘会存储一部分独一无二的数据，这样可以多块磁盘同时进行读写操作，效率会很高，当然如果某个磁盘损坏了，那么这块磁盘的数据也就 丢了，示意图如下：

![image-20210108174401993](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210108174417.png)

RAID-1的架构恰好可以解决RAID-0的数据丢失问题，若设备中有两块磁盘，那么RAID-1架构会将其中一个磁盘作为一个整体，另一个磁盘作为一个冗余备份对象，每次进行磁盘读写操作时，主备磁盘执行一样的指令，那么两块磁盘的数据完全相同，当一块磁盘损坏时，那么还有备份磁盘可以使用，示意图如下：

![image-20210108175013209](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210108175028.png)

RAID-10是前两种架构的结合，至少是需要4块磁盘进行配置，其中几块磁盘分别存储不同发数据，同时还有数量相同的几块磁盘进行备份，示意图如下：

![image-20210108175330301](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210108175330.png)

当然，从效率性能来看，RAID-10架构是最好的，但是相应的成本也是最高的。除了这三种磁盘架构外，各个服务器厂商都有对RAID进行特有的优化和调整，每家的都不相同。

##### 磁盘阵列独立电源导致磁盘性能抖动问题

在数据写入磁盘时，会经过这个磁盘冗余阵列，确定数据写入那块磁盘中，但是接下来并不是直接进行磁盘写入，而是将请求数据写入一个SDRAM内存中，之后再慢慢将内存中数据刷入磁盘。

但是这会出现一个问题，那就是如果服务器突然断电了，那么SDRAM中的数据就会直接丢失，所以服务器中都有配备给SDRAM的独立电源，当服务器断电时，SDRAM切换为备用电源，继续将内存数据写入磁盘，示意图如下。

![image-20210109141337649](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210109141346.png)

独立电源虽好，但是长时间的不使用是容易损坏的，需要每隔一段时间进行一次完全的充放电行为，期间SDRAM缓存会停止工作，缓存级别由write  back改为write through，那么数据会直接写入磁盘，但是此时的磁盘写入效率会极具下降，大概会变成缓存写入效率的1/10。

那么处理方案是什么呢？一般有两种，一种是在进行电源充放电时不修改缓存级别，还使用write  back；二是关闭默认定时充放电功能，由人工脚本在系统使用低峰的夜晚，进行手动充放电操作，这样可以避免在业务高峰的数据存储抖动问题。一般两种方案同时兼容使用。

##### Too many connections问题

对于维护数据库连接数量来说，如果超过了数据库配置max_connections，那么再进行数据库操作，就会出现这个问题。

我们可以先通过命令查询数据库当前的连接状况：

```sql
//查询数据库最大连接数
show variables like 'max_connections'
//查询数据库当前连接数
show status like '%Threads_connected%'
```

如果的确是最大连接数用完了，那么在my.cnf配置文件中加入max_connections手动扩大配置数，之后重启mysql就好了。

如果配置没有生效则可以考虑linux系统的限制进程打开文件的句柄数量是否过小，配置曹仁如下：

先使用ulimit -a命令查询linux设置的open files数：
使用命令lsof -p 进程id | wc -l查询当前某个进程打开的句柄连接情况

处理：
1.增加linux ulimit设置的open files上限(ulimit -u 新上限数)
2.发现代码中未关闭的资源，处理掉就ok了