mysql-9(表锁与行锁)

### 表级锁和行级锁

#### 行级锁 

行锁简单的说就是，一个事务对id=1的数据行进行了修改，还未提交，另一个事务也修改了这条数据，但是提交时会阻塞，必须等前一个事务的行锁释放后才能提交

在之前的事务隔离等级中，提到了RC级别可以避免脏写，那么数据库是如果实现避免脏写的逻辑 的呢？答案其实很明显，就是给数据进行加锁，使修改数据行的事务们串行化执行，这样就可以保证数据的一致性了。

mysql中对于数据行的加锁过程大概是这样的 ：当一个事务要修改一个数据行时，首先会判断当前 数据行有没有被加锁，若没有，就会创建一个行级锁对象 ，然后将这个锁对象关联到对应的数据行中，之后再进行数据修改，直到事务提交后释这个锁对象，示意图如下 ：

![image-20210115162039872](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210115162133.png)

如果在事务A上锁过程中又来了一个事务B要修改这条数据，事务B在判断数据行时发现数据已经被事务A上锁，就不能立即关联上锁修改数据，而是会创建一个锁关联到数据行上，但是锁状态是等待状态，示意图 如下：

![image-20210115163631477](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210115163631.png)

当事务A提交后就释放锁，这个时候事务A的 工作还没有完全完成，它会遍历这条数据行的加锁 列表 ，判断是否还有其他事务也关联上锁了，但是却处于等待状态的事务，如果有就按照顺序唤醒之后的一个事务来修改数据，示意图如下：

![image-20210115164505864](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210812091406.png)

这就是事务与事务的隔离，通过数据行加锁，一次只能有一个加锁对象来操作数据，保证事务操作同一数据的顺序写，这样的锁可以称为互斥锁或是独占锁。

当然这个加锁互斥只针对于修改数据的事务，对于查询数据的事务来说，并不会需要等待加锁对象执行完后才能查询，查询事务遵循的是ReadView机制，完全可以避免查询到不应该查询的数据。

但是，如果需要，也可以将查询语句也加锁，这样查询事务和修改事务也会互斥执行，在查询事务未执行完前，其他事务就修改不了数据，只不过这样的业务场景非常的少，在实际开发中基本用不到；给查询语句的加锁分为两种情况：

- **共享锁**：共享锁和独占锁是同级别的锁，而且共享锁和独占锁是互斥的，也就是一个查询语句如果加了共享锁，那么在事务查询中其他修改目标数据的事务是会阻塞等待的；但是共享锁还有一个特点，那就是共享锁之间并不会互斥，也就是多个查询事务可以同时给一个目标数据加不同的共享锁，而且可以并行。

  ```sql
  -- 在查询语句后加共享锁（lock in share mode）
  select * from table lock in share mode;
  ```

  

- **独占锁**：查询事务也可以加独占锁，加锁代码如下：

  ```sql
  -- 在查询语句后加独占锁（for update）
  -- for update会锁表，慎用
  select * from table for update
  ```

最后说一下独占锁和互斥锁的互斥关系 ：

```
共享锁 +  共享锁 ---> 不互斥
共享锁 +  独占锁 ---> 互斥
独占锁 +  独占锁 ---> 互斥
```

#### 表级锁

当update、delete等索引失效后，行级锁会升级未表级锁，此时，在当前事务未提交时，其他事务提交数据都会阻塞

有一些情况下会给整张数据表加锁，也就是在表级锁加锁期间，所有的增删改查事务都会阻塞；一般来说，像修改表结构的DDL语句(Alter table...)就会给数据表添加表级锁，它是通过Mysql的通用元数据锁(Metadata Locks)实现的。

表级锁分为两种，一种是表锁，一种是表级意向锁

先说表锁，可以分别表级共享锁和表级独占锁，加锁语法如下：

```sql
--表级共享锁
lock tables  table-1 read
--表级独占锁
lock tables  table-1 write
```

然后是表级意向锁，分为意向共享锁 和意向独占锁，这两个锁之间一般来说都不会互斥，而且在事务修改数据行时，一般就会在表级添加一个意向独占锁，由于这个锁 很少互斥，所以一般没 说明作用。

下面 我们 来汇总说明一些下四种锁的互斥关系：

| 锁类型     | 意向共享锁 | 意向独占锁 | 共享锁 | 独占锁 |
| ---------- | ---------- | ---------- | ------ | ------ |
| 意向共享锁 | 不互斥     | 不互斥     | 不互斥 | 互斥   |
| 意向独占锁 | 不互斥     | 不互斥     | 互斥   | 互斥   |
| 共享锁     | 不互斥     | 互斥       | 不互斥 | 互斥   |
| 独占锁     | 互斥       | 互斥       | 互斥   | 互斥   |

以意向独占锁为例，如果我们手动加了意向独占锁给目标数据表，那么此时这个数据表的所有数据都没法更新，因为意向独占锁和独占锁互斥。

记忆方式：

独占锁和四种锁都互斥

共享锁和两种独占锁互斥(和两种共享锁不互斥)

意向独占锁和非意向锁互斥(和两种意向锁不互斥)

 意向共享锁自核独占锁互斥(和其他三种锁不互斥)

#### 间隙锁

当我们使用update、delete命令对一个范围内的数据行信息批量操作时，会对这个范围内的所有数据行加锁，比如数据行的id分别为(1,2,3,5)，如果我们使用id>1 and id <5的命令来进行update时，会对范围内的数据行都加锁，这样会产生间隙：没有id=4的数据行，在当前事务未提交前，如果刚好插入一条id=4的数据行，这个插入会被阻塞。

参考：https://zhuanlan.zhihu.com/p/159618355

#### 处理Mysql性能抖动问题

如果在mysql性能监控中 发现数据库每隔一段时间就会出现一次性能极具降低，之后又恢复的状况 。这种抖动可能是下面几种状况导致的：

1. buffer  pool中的空闲缓存页已经用完，此时新的查询事务需要加载很多数据页到buffer pool中，就必须要等到将当前buffer pool中lru链上的脏页刷入磁盘后才能清空这些缓存页，所以 ，这个查询事务必须要等到脏页刷完后才能开始查询
2. 当两个redo.log文件都已经写满时(默认配置是2个)，如果再继续进行数据库更改操作，则会覆盖第一个 redo.log文件继续存储redo数据信息；但是，这里有个前提，那就是在覆盖第一个redo.log文件前 ，要将这第一个redo.log文件对应的缓存脏页刷入磁盘中后，才能进行覆盖写入(如果直接覆盖写入，那么此时数据库宕机，则会丢失第一个redo.log的恢复数据)；所以，这种情况下也要等到脏页刷盘完成后才能继续开始业务执行

处理方式：

1. 加大buffer pool的大小，增加缓存页数量减少脏页刷盘的频率

2. 加快脏页刷盘的速度

   

第一种方式可以通过加大buffer pool和chunk块的大小，或者增加buffer pool的的数量来增加缓存页的数量。

第二种方式就是加快脏页刷盘的速度和减小脏页的数据量，加快脏页刷盘的的速度可以通过加大innodb_io_capacity(实际io刷盘速度，默认为200)配置来实现 (一般SSD磁盘的IO一般可以达到5000作用)。而减小脏页的数据量可以通过将innodb_flush_neighbors(默认值为1)配置设置为0来实现，因为在实际的刷盘脏页中会将脏页相邻的数据页也刷入磁盘中，配置为0后，就会只刷入脏页了。 

