mysql-5(行数据的物理结构)

### mysql存储数据的物理结构解析

在了解新知识前，先先回答两个问题：

- 为什么不直接修改磁盘中的数据，反而要整一套复杂的内存模型来处理数据？

答：磁盘的访问操作效率和内存的操作效率没法比的，可以简单的理解为磁盘读写速度是汽车的速度，而内存的的读写速度是飞机甚至火箭的速度；若直接操作磁盘来修改数据，那么效率必然极其的低下，访问量一大就容易囤积请求，导致服务宕机。

- 为什么要引入数据页的结构，而不是一条一条数据的结构？

答：数据页的引入可以减少IO频率，如果buffer pool存储的是一条条的数据，而不是一个个数据页，那么每修改一条数据那么就会有两次IO(从磁盘中查询到内存一次，写入磁盘一次)，而且每条数据都至少有一次IO操作，这样必然导致数据库的处理效率降低。而使用数据页后，可能你修改的多条数据是属于同一个数据页的，那么操作多条数据最多有2次IO(首次加载数据页到内存，最后将数据页刷入磁盘一次)，这样效率就得到了极大提升。

#### 一、一行数据是如果物理存储的

我们在使用数据库时，接触的数据格式一般是这样的：

mysql数据库->包含多个库->每个库包含N张数据表->每张表包含N个字段

开发中，一般是以数据表为存储单位，实现一块业务对象数据的存储，而且经常还使用需要使用关联字段实现表关联查询。

以上的内容都是数据的逻辑存储结构，并非数据的物理存储结构，那么一条数据的物理存储结构是怎样的呢？

首先，我们在创建一个数据表时，都会指定一个数据行存储格式ROW_FORMAT，这个格式就是指定一条数据是以怎样的格式存储在物理磁盘中的，一般来说有COMPACT、DYNAMIC、FIXED、DEFAULT等几种存储格式。

下面以COMPACT格式来解析一条数据的存储：

以COMPACT格式存储表数据，大概的物理逻辑图如下：

![image-20210104114301967](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210104114302.png)

一条数据的存储分为三个部分：数据头，左边的汇总描述数据，以及右边的具体字段值列表

我们先来看左边汇总描述数据，这部分数据是以倒序的方式，存储了一行数据的总体状态信息，如不定长类型字段长度列表：varchar等长度不固定字段的具体长度，存储进制为十六进制；null值列表：以bit位存储了该条数据行那些字段为null，用0代表字段非null，用1代表字段为null。

然后是中间的数据头，他的长度是40个bit位，分别用不同的位数表述不同的信息，如：标记该条数据是否删除，该条信息的存储位置等待。

数据头右边是该数据行的每个有值字段的具体属性值。

一般查询一条数据会先根据偏移量找到数据头，之后向左读取获取数据行的不定长类型长度列表和null值列表，这样就清楚不定长字段的具体长度和哪些字段为null了，之后按照顺序读取数据头右边的顺序字段属性值，这样就能顺序读取出该行数据值了。

**下面来举个例子**：

有一个用户表，字段详情如下

```sql
create table sys_user(
	id varchar(32) not null primary key,
    username varchar(32),
    gender char(1),
    job varchar(32),
    address varchar(32)
) ROW_FORMAT=COMPACT;
```

现在插入一条数据：(11111111   NULL   m    NULL   北京市)，其中的username和job字段为NULL，那么

我们来按照COMPACT的存储格式来分析一下这条数据：

首先是不定长字段有四个，id字段、username字段、job字段和address字段，其中id字段值为11111111 ，长度转成十六进制为0x08，address字段值为北京市，长度转成十六进制为0x03，其余两个字段为NULL不表示；所以不定长字段长度列表为(倒序)：0x03   0x08

之后是null值列表，这行数据只有username和job字段为NULL，之前我们已说明用bit位来表示一行数据的NULL字段(0为非NULL字段，1为NULL字段)，由于id字段是not null字段，所以不计入null列表中，剩下的四个字段可以表示为1010，再倒序一下是0101，为了保证bit和字节的转化关系，所以bit位一般是8的倍数，不足补零。

那么整条数据可以表示为：

[0x03   0x08 00000101  数据头   11111111   m   北京市]  [后边直接跟下一条数据]

这样，我们在查询这条数据时，先提前知道了各字段的类型和修饰符，再根据数据头向左读取，根据null值列表知道所有字段为不为null，根据不定长字段长度列表知道每个不定长字段的具体长度，根据这些数据去数据头右边读取具体的字段数值，这样整行数据就出来了。

当然，数据库不可能直接将中文，英文等字符直接写入磁盘中，肯定是要经过编码转化之后才会存储起来，所以更接近真实的存储格式可能如下：

[0x03   0x08 00000101 {00000000 00000000 00001001 00111101 01011111}   11111111   6689   45645645666] 

#### 二、行溢出

在之前，我们说明过数据页的大小是16kb，而在定义字段大小时，可以定义varchar(60000)、text、blob等类型的字段，但是这些字段的长度远远大于了16kb，一个数据页是容纳不了的，这里就会数据行的溢出。

当数据行有字段溢出时，一个数据页只会存储一小部分数据，然后接一个20字节的指针，这个指针指向其他的数据页，也就是说当数据行溢出时，这些溢出的数据时分散存储在多个数据页中的，每个数据页通过指针进行连接组成链表；示意图如下：

![image-20210104201250635](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210104201259.png)