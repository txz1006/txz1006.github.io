mysql-10(索引与查询原理)

### 索引与查询原理

#### 一条数据是怎么查询出来的(数据页的关联与定位)

查询一条数据实际上就是在一堆数据中将目标数据筛选出来，既然要筛选就不可避免的要涉及到数据行的遍历，而遍历数据行就需要给数据行之间添加联系(指向关系)；除了数据行外，对应数据行的容器对象数据页来说，页需要有和相邻数据页的指向关系。

所以，对于一个数据表来说，他的相邻数据页是通过双向链表来连接的；而数据页中的数据行 是通过单向链表连接的，示意图如下：

![image-20210117152330592](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210117152425.png)

数据页通过指针指向另外一个数据页的起始位置，数据行页通过指针指向下一个数据行的起始位置 。

如果我们要查询某条特定的数据，就要用到这些关联关系了，在讲解之前还有两点知识需要说明，那就是数据页和数据行都是按照一定规则顺序排列的(可以简单理解为按照主键从小到大排列)；而且在数据页中会有一个目录表结构，会记录一个K-V数据(主键-对于数据行在数据页的槽位)，这个目录就是用来加快检索速度的，示意图如下：

![image-20210117153555249](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210117153555.png)

在知道这些点后，下面我们来说明一条数据是怎么查询出来的(在没有任何索引的状况下)。

如果现在有一个数据表，目前只有一个数据页，我们要通过主键查询某条目标数据行。Mysql首先会查询到这个数据页，将其加载到buffer pool中的缓存页中，之后会使用二分法遍历数据页的目录表，根据主键找到数据行所在的槽位，再跳转到对应槽位遍历其中的数据行就能找到目标数据了。

如果有多个数据页的情况下，那么就会通过数据页的双链表一个个数据页的往下遍历，直到找到所有符合查询条件的数据行为止，这也就是**全表扫描**。

#### 页分裂

在上一节中我们知道，如果没有索引，几乎所有的查询都需要通过遍历数据页、数据行来一点点的扫描数据来实现，这是效率非常低的查询，所以就一定要通过建立索引来降低这个查询的复杂度。

而降低复杂度就要用到我们熟知的一些查询算法，如二分法、树结构等等，但是这些数据结构的 使用都需要在遍历数据是按照一定规则排序的前提 下才能使用。所以，下面我们来讲一个点，即mysql是如何通过也页分裂来保证数据行在数据页中是有序排列的。

我们知道数据行在数据页中是一条条的插入的，当数据页达到16K时，就会创建下一个数据页来存储新数据。而在每一个数据页中数据行通过指针单向链接，更关键的是，这个单向是按照某个字段从小到大排序的(一般是主键)，示意图如下：

![image-20210117160415921](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210117160416.png)

以上图为例，每个数据页的第一个数据行的行类型为2，意为最小数据行；同理最后一行行类型为 3是最大数据行，中间的是0是普通数据行，这样下一个数据页的最小数据行就一定比上一个数据页的最大数据行的id大。这一切都是在数据行有序递增的情况下进行的(一般是 按照主键递增)，但是有些时候，我们的主键是UUID这样的非有序自定义字段，那么就会产后后面插入的数据行id比之前的数据行id小的状况，而且很可能这些数据行还不在同一个数据页中，示意图如下：

![image-20210117161350961](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210117161351.png)

出现这种情况时，MySQL就会通过页分裂行为中，根据id的大小，从小到大重组数据行的指向位置。以上图为例，即将id=2的数据行插入到数据页1中，而将 id=7的数据行 挪到数据页2的最后位置 (将id=1的数据行指向id=2的数据行、id=2的数据行指向id=3的数据行，取消id=5数据行的next指向，将数据页2的最小指针指向id=6的数据行，同时next指向数据行7)

这样，数据页中的数据行就按照了从小到大的顺序排列 ，而且相邻的数据页中 ，后一个数据页的最小数据行比前一个数据页的最大数据行的id大。

#### B+树与聚簇索引

在上一节中，我们知道数据页和数据行都是有序排列存储的，那么以主键为例，主键索引大概时扫描样的呢 ？下面 我们来了解一下 ：

首先，索引也是存放在一个个数据页中的，我们 称之为索引页。而索引页中存放的是连续数据页的最小主键和数据页初始地址，示意图 如下 ：

![image-20210117165113429](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210117165113.png)

这样，如果我们要查询某个id具体的数据行，通过二分法遍历索引页就能很快找到对应的数据页了。

但是如果数据页非常的多，多到一个索引页记录不完怎么办？

答案是在创建多个索引页，而且在此基础上创建一个父索引页，这个父索引页保存每个索引页的最小主键地址和对应索引页地址，示意图如下：

![image-20210117170447119](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210117170447.png) 

如果数据更多就会在此的增加父级索引页，到最后会形成一个B+树的索引结构，而树的叶子节点就是一个个的数据页，非叶子节点就是 一个个的索引页，这样的结构通过数据表的主键来实现，所以也称为**聚簇索引**(注意：聚簇索引是一种数据存储结构，表明数据具体存储在索引树的叶子节点上)，示意图如下：

![image-20210117171752933](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210117171753.png)

除了父子节点的指针指向外，同一级别的的数据页或索引页也会有双链表链接。

最后来总结一下，如何通过聚簇索引来查询某个具体id的数据行，以查询id=2的数据行为例。

首先，在索引页0中使用二分法查询id=2的数据行在哪个子索引页中找索引页1，在索引页1中使用二分法查询到id=2的数据信息在索引页4中，在索引页4中使用 二分法查询到id=2的数据行在数据页2中，最后找到数据页2，使用数据页的目录表查到id=2的数据行在哪个槽位中，并遍历槽位数据取到id=2的数据行。

所以在进行增删操作时，除了修改数据行数据外，也会调整数据页之上的索引页 结构，特别是在页分裂出新数据页时。 

#### 非主键索引和回表

之前讲的聚簇索引是对于主键的索引查询，而对于非主键的普通字段，它的索引也是类似的。假如数据表中有个name字段，现在我们要给这个字段添加索引，那么mysql就会给这个字段新创建 一个索引结构，一般也是树结构。 

而且这个name索引是根据name字段计算的数值按照从小到大排列的，和聚簇索引的id排序类似。并且也会根据name划分多个索引页，这样我们查询name=XXX的数据行时，就会根据这个name索引找到最后的叶子节点 。只不过这个叶子节点并不是数据页本身，它只会记录数据行id和索引字段name的数值，示意图如下 ：

![image-20210117174240183](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210117174240.png)

也就是根据name索引我们只能查询到目标数据行的id值列表，这肯动还没有查询完成；而剩下的工作就是 **回表**了，简单的说就是根据name索引查询出来的主键列表，再次根据这主键列表到聚簇索引中再查询一遍，直到查询出对应的数据行为止。

如果是多个字段的联合索引，那么索引页就会存储id、name、age等多个索引字段信息，在索引排列时也会先按照name排列、name相同时就按照age排列；在查询时就可以根据索引字段条件查询满足条件是id值，  再根据id进行回表查询数据行就完成了整个查询过程。(注意：联合索引要满足最左原则，因为在建立索引时是按照索引字段从左到右的顺序进行排列的，所以查询条件 中一定要有联合索引的第一个字段才会生效。例如index(a,b,c)三个字段，那么只会有a、a+b、a+b+c三种 查询方式，不支持a+c、b+c字段的索引查询，因为这个联合索引是以a字段为排列基础建立的；而且a字段的数值分类越少，效果越好)

常见的几种索引类型：

- 聚簇索引(聚集索引)
- 辅助索引(二级索引、非聚簇索引)
- 辅助索引包括->唯一索引、前缀索引、联合索引等等


通过上面的介绍，我们可以知道了mysql的存储数结构实际上就是一颗B+树，下面我们来回顾一下b树的一些要点：

B树的特点：
B树，也就是平衡树(balance tree)，所有非叶子节点的子节点数是大于等于2的、叶子节点必须要在同一层上，序号不会重复存储，所有节点不仅存储序序号，还存储的有数据。

B+树，是B树的变体，所有非叶子节点只存储序号，不存储数据当作索引使用，只有叶子节点会存储数据，而且每个叶子节点会重复存储父节点的序号，而相邻的叶子节点还会通过双链表信息进行指向方便遍历。

