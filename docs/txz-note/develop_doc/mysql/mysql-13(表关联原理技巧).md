mysql-13(表关联原理技巧)

### 表关联原理技巧 

#### 驱动表和被驱动表 

下面我们来简单分析下表关联查询的执行逻辑，来看一条sql：

```sql
select t1.*,t2.* from t1,t2 where t1.type =  1 and t1.pid = t2.id
```

这个sql是t1表和t2表的关联查询，那么mysql会怎么执行这个sql呢？其实也不难，首先这个语句会拆分为几个查询步骤：

第一步，查询t1表中type字段等于1的所欲数据行，得到一个结果集s1

第二步，将s1结果集中的pid字段作为条件，查询t2表中id与之对应的数据行，并得到结果集s2

第三步，根据t1.pid = t2.id的关联规则，将结果集s1和s2的数据行一样对应拼接起来，得到最终的查询结果。举个例子，假如t1表中type=1的数据行只有一条，而根据这条数据在t2表中查询到有2条关联数据，那么在合并的时候会循环t2表查询到的两条数据，用t1表的那条数据与之一一关联，那么就会得到两条结果数据行。

用伪代码的方式表示就是：

```js
t1Rows = queryFromt1(type =  1)  //查询t1表type=1的数据
for(t1Row in t1Rows){
    t2Rows = queryFromt2(t1Row.pid)  //查询t2表中id和t1.pid相同的数据
    ResultSet result = null
    for(t2Row in t2Rows){
    	result.add(t1Row + t2Row)
    }
    return result
}    
```

这里总结一下，一般先查询出一波数据的表称为**驱动表**(左边的表)，而需要根据驱动表的数据查询另一个表的数据，这个另一个表就是**被驱动表**。

所以说，表关联查询速度就取决于这一步步的的查询执行计划，可能是走索引、也可能是全表扫描；当然，全表扫描会导致效率极低，最好对驱动表和被驱动表添加对应的索引，避免关联表的全表扫描。以上示例sql来说，对于t1.type添加二级索引，t2直接使用id的主键索引。

另外，需要说明一点，如果t1表中的有一条id=3的数据在t2表中没有查询到关联数据，以上述sql为例，那么在查询的结果中就不会出现这条id=3的数据。所以，from后以逗号分割多个表名，并在where后指明关联条件的这种查询方式就是**内关联查询**，等同于inner join查询。

![image-20210123162244891](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210812110631.png)

#### 内关联和外关联查询

还是上一节的sql，如果用内连接的表示方法来就是下面的形式：

```sql
select t1.*,t2.* from t1 inner join t2 on t1.pid = t2.id where t1.type =  1 
-- ps:inner join内连接的inner关键字可以省略不写，等同于：
select t1.*,t2.* from t1 join t2 on t1.pid = t2.id where t1.type =  1 
```

两种写法的查询结果完全相同。

下面我们来另外一种情况，那就是需要显示t1表中没有关联到t2表的数据，这就需要涉及到外连接(outer join)了，外连接分为左连接(left join)和右连接(right join)两种，左连接会显示全左表的全部数据，无论是否关联到被驱动表的数据，左表的数据一定会显示全，没有关联到被驱动表的数据行只展示左表数据，其余字段显示null，示意图如下：

![image-20210123163754505](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210123163754.png)

右连接刚好相反，会显示全被驱动表的全部数据，和左表没关联上的数据也显示null，示意图如下：

![image-20210123164007472](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210123164007.png)

#### 查询成本计算规则

在一个查询sql被执行过程中，mysql会解析这个sql得到一个执行计划，这个查询计划是mysql根据一套sql执行成本算法大概估计出来的，接下来我们就来了解下sql成本的相关知识。

首先查询语句的预估成本可以分为两部分，一部分是IO成本，即mysql从磁盘中取出相关数据页的消耗，公式是[数据页数量 * 1.0 +微调值]；还有一部分是CPU成本，是mysql在数据页中寻找目标数据和在内存中处理加工查询结果(排序、分类、函数)的消耗，公式是[数据行数量 * 0.2 +微调值]，微调值近似可以忽略。

在查询一条语句时，mysql会分别计算下这个sql在全表扫描的成本和在索引扫描的成本，哪个成本小就可能优先按照成本小的方式执行。

下面我们来分别了解下全表扫描的成本和索引扫描的成本计算规则：

**全表扫描成本计算：**

我们还是来一个 sql示例一下：

```sql
select * from t where x1 = xx and x2 =xx
```

在全表扫描的情况下，mysql会将聚簇索引的叶子节点(数据页)一页页的加载到内存中，然后依次遍历每个数据页中的数据行，判断x1和x2字段是否符合查询条件来筛选结果。

首先我们来计算下这个sql的IO成本。我们需要查询一下这个表的整体数据存储状况来获取数据页的信息，sql是：

```sql
-- 查询数据表存储信息
show table status like '表名'
```

以会得到这样的结果，示意图如下：

![image-20210123173421404](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210123173421.png)

我们只用关注Rows和Data_length两个字段信息就行了，Rows是当前数据表有多少行数据，Data_length表的整体聚簇索引的字节数大小，我们可以通过公式[Data_length/1024/16]来计算这个表有多少个数据页。以上图数据为例16384/1024/16=1，刚好是1一个根数据页。

如果这个表有100个数据页，大约有2万个数据行，那么全表扫描的成本大概是：

```
IO成本：100 * 1.0 
运算成本: 20000 * 0.2 
全表扫描成本是： 100 + 4000 = 4100
```

**索引成本计算：**

通过索引来执行时，一般就通过二级索引来扫描数据，在通过主键id回表到聚簇索引查询完整数据行数据。

所以索引成本一般有下面几个部分组成 ：

1.IO读取索引页的个数，一般简单认为是where后有几个字段匹配，就粗暴认为有几个索引页要IO读取，公式是[n * 1.0，其中n是索引页数量]。举个例子，如where x1=1 and x2=3，就可以认为要查询两个索引页，那么IO成本就是 2 * 1 = 2

2.之后是索引页的CPU成本，假设能够查询到200条数据，那么成本是200 * 0.2 =40

3.拿到索引页的200条索引数据后，就会根据这条数据到聚簇索引中进行回表，一般一条索引数据对应一个数据页，所以这里还有聚簇索引数据页的IO成本，这里是200 * 1.0 =200左右

4.最后一步是在聚簇索引的数据页中寻找这200条数据的完整数据行的CPU成本，也是200 * 0.2 =40

把所有成本加一起得到最终成本：2 + 40 +200 +40 = 282，这个结果和全表扫描的差异是非常大的。

**关联查询规则：**

关联查询的成本计算其实和单表查询类似，因为多表查询完全可以解析成多个单表查询步骤，再用之前的成本公式计算即可。例如：

```sql
select * from t1 join t2 on t1.x1=t2.x1 where t1.x2=xxx and t1.x3=xxx and t2.x4=xxx and t2.x5=xxx
```

以上面的sql为例，首先以t1表为驱动表查询t1.x2=xxx and t1.x3=xxx的一波数据，至于到底是使用x2字段的索引、x3的索引，或是全表扫描。通过索引成本计算公式即可。选择成本最小的方式查询到一波结果后，根据t1表结果的x1、和t2表的x4、x5三个条件到被驱动表进行查询，这同样可以更具索引成本计算公式得到结果，将成本加在一起就是关联的总成本。

**执行语句的自动优化规则:**

在执行一个查询sql时，mysql会自动帮我们简单优化一波，让sql语意更明晰，更容易解析，下面会讲解一些优化的规则。

1. 对于where a = a  and b = b这样没有意义的条件的条件会在优化中直接删去

2. where i = 5 and k > j会优化成 k > 5

3. 类似select * from t1 join t2 on t1.x1=t2.x1 and t1.id=1，mysql会提前查询出t1表中id=1的数据行来代替这个sql中有关t1的数据，可能会变为：select t1表的索引字段名，t2.* from t1 join t2 on t1.x1的常量=t2.x1

4. 像select * from t1 where x1 in (select x1 from t2 where t1.x2=t2.x2)这样的语句，mysql会先查询出子语句select x1 from t2 where t1.x2=t2.x2的结果集，并在内存中或磁盘中生成一个临时表，之后会以这个临时表为驱动表来关联查询出t1表的数据，而不是直接对t1表进行全表扫描。

   

