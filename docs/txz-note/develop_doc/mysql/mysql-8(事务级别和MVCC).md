mysql-8(事务级别和MVCC)

### 事务级别和MVCC机制

#### 事务级别

数据库的基本操作单位是事务，但是事务和事务之间的如何处理，这是每个数据库都要处理发问题，如A事务能否读取到其他事务的修改过的数据(此时事务都没提交)， A事务能否读取到其他事务新增的数据等等。

事务的四种特性 ：

**原子性、一致性、隔离性、持久性**

事务和事务之间的特性可能会产生三种问题：

**脏读脏写**：A事务读取了事务B修改后未提交的数据，之后事务B回滚 ，而事务A是在事务B的基础 上修改的数据，此时就产生了脏读；多各事务可以同时操作同一个数据，会导致脏写。

**不可重复度**：A事务多次查询同一条数据，此数据同时被其他事务多次修改，导致A事务多次查询的结果会发生变化  

**幻读**：A事务多次查询同一表数据，此数据同时被其他事务多次新增/删除，导致A事务多次查询的数据数量会发生变化  

所以，数据库一般都会有一个事务等级来处理这三种问题：

事务等级一般分为4个等级，依次兼容处理上述 问题 ，但是性能会逐步降低

**读未提交**：不会发生脏写，会 发生脏读、不可重复度、幻读问题，一般不会使用此级别

**读已提交**：不会发生脏读脏写，会发生不可重复度、幻读问题(简称RC级别)

**可重复读**：不会发生脏读脏写和不可重复度问题，会发生幻读问题(简称RR级别，MYSQL默认就是这个级别，而且可以避免幻读，参考https://www.jianshu.com/p/4c02a3a2e9d2)

**串行化**：事务同步执行，效率极低，一般也不 使用

#### undo日志链 

一个数据行除了有开发者自己定义的字段外，还有一些隐藏字段，如row_id(数据行唯一 标识)，trx_id(最近一次修改数据行的事务id)，roll_pointer(指向最新事务的undo日志地址)，而在undo日志链中就用到了trx_id和 roll_pointer。

以插入一条数据为例，有一个事务(id=32)给一个数据表插入了一条数据，那么这条数据的隐藏字段就有这样的内容：

![image-20210112154733278](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210812110607.png) 

插入数据行的trx_id记录了插入事务的id， roll_pointer记录了修改前的undo日志地址，首次插入时 roll_pointer指向null。

当我们第一次修改这条数据时，就会形成一个undo日志链：

![image-20210112155330252](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210112155330.png)

二次修改这条数据就会在加长undo数据链

![image-20210112155659907](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210112155659.png)

#### MVCC机制

MVCC机制就是数据库实现来隔离事务，防止出现脏读幻读等问题的套逻辑。下面来了解mysql是如何实现并发版本控制机制(MVCC)的：

在Mysql中实现MVCC的主要是ReadView对象，开启一个事务时，会生成一个ReadView对象，这个对象主要由四个字段组成：

```
m_ids:指当前还没提交的事务id列表
min_trx_id: 指还没提交事务中(m_ids中)最小的事务id 
max_trx_id: 指mysql要生成的下一个事务id，作为当前readview最大事务id
creator_trx_id:指创建当前readview对象的事务id
```

现在来举一个实例 ：现在有两个事务同时访问mysql，一个事务A(id=32)用于查询某条表数据，一个事务B(id=48)用于更新这条 表数据 ，那么就 会由事务A生成一个ReadView对象，大概的值如下：

```
m_ids: 包含事务A的id值32和事务B的id值48
min_trx_id: 一般就是创建readview的事务id，32
max_trx_id: 肯定比当前所有 没提交的事务id大，这里给个值56
creator_trx_id: 32
```

创建ReadView之后，首先会有一个判断，查询这条数据当前的trx_id值，也就是这条数据在事务A之前最后提交的一个事务id，用事务A的trx_id和数据行的 trx_id比较大小，如果事务A的trx_id大，则代表可以查询到当前数据行信息。

此时，事务B得到了执行，将这条数据进行了修改，同时将数据行的 trx_id更新成了事务B的trx_id值48，将roll_pointer指向了之前的trx_id=32的undo日志链。

事务B修改数据行后，事务A再次查询这条数据，比对trx_id时发现32没有48大 ，而且在readView对象的m_ids列表中查询到了这个事务(事务B还未提交)，所以此条数据行的最新值是不会被查询到的，而是顺着undo日志链向后寻找 第一个小于等于32的trx_id所在的数据值，然后将这个数据显示出来，这样对外的表现就是一个事务多次查询这条数据，这条数据并没有发生变化。

当然，如果有另外一个事务C(trx_id=102)来修改了这条数据 ，那么事务A再次查询时，发现这条数据的 trx_id已经变成了102，已经比readView对象的max_trx_id大了那么也是不能直接显示的。

![image-20210112175307990](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210112175308.png)

#### RC事务级别是如何实现的

RC隔离级别：每次读取数据前，都生成一个readview；

![image-20210114160639251](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210114160713.png)

还是以上面的事务A和事务B为实例，事务 A第一次 查询 时会生成一个ReadView，此时，无论事务B修改数据行后是否已经提交，在ReadView中还能查询到事务B的id，因为ReadView是一个快照数据对象，一旦 生成就不会修改了，所以事务A不会读取到事务B修改后的数据；但是当事务B提交后，事务再次查询时，在RC级别的事务会再次生成一个ReadView对象，虽然此时数据行的trx_id已经改成事务B的id了，比事务A的id大了，但是在新ReadView对象的m_ids中并没有事务B的id，说明 事务B已经提交 ，那么就可以显示事务B修改后的数据了。 

#### RR事务级别是如何实现的

RR隔离级别：在第一次读取数据前，生成一个readview；

和RC级别的区别是，一个事务在第一次读取数据前生成ReadView对象，而且事务期间内只会生成这一个ReadView对象。 

以上面的事务A和事务B为例，那么无论事务B是否提交了，由于ReadView并没有变，在m_ids中一直有事务B的id，所以不会查询到事务B修改后 的数据，这样就实现了可重复读；与此同时，若有另外一个事务C给查询的数据表新增了一条数据，这条新数据的trx_id和事务C一致是69，这条数据对于事务A来说也是查不到的，因为它的trx_id已经大于了ReadView的最大事务id，这样就避免了幻读。

