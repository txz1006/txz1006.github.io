mysql-11(索引与查询原理2)

### 索引与查询原理2

#### 索引和页分裂创建过程

假如我们创建了一个新表，这个表只有几条数据，那么这个表的物理存储结构很可能只有一个数据页，这个数据页中有按照主键顺序排列的目录页，我们可以根据这个目录页来查询到具体的数据行。

这个初始的数据页实际上也是这个表的根页，当这个根页被数据行插满时，就会开始页分裂，首先它会创建一个空数据页，将根页的数据复制到其中；然后会创建另外一个空数据页，用来存储新插入的数据行；之后会根据主键的大小对两个数据页的数据行按顺序调整排列，保证第二个数据页的最小数据行id一定比第一个数据页的最大数据行id大。三个数据页示意图如下： 

![image-20210117165113429](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210117165113.png)

随着数据页的增加，每加一个数据页就会在这个父索引页中插入一条索引记录，直到这个索引页也装满为止。若此时再增加数据页，则索引页也会进行页分裂(复制出一个索引页，创建一个新索引 页，将原来的索引页升级为父索引页)，最后会从二级树变为一个三级树结构，索引裂变示意图如下：

![image-20210117170447119](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210117170447.png)

数据越增越多，最后变成一颗按照主键顺序排列的树结构，这棵树叶子节点是具体是数据页，而非叶子节点则是索引页，这就是**聚簇索引**了。

此外，增加数据行除了会导致聚簇索引的的数据页变化或树结构调整外，也会调整非主键索引树的信息和结构。

比如用户插入一个新的人员数据，这个人员表有个name索引，此时除了将这个数据行插入到聚簇索引的数据页中，也会在name索引树中增加对应的索引数据。由于非主键索引数值是会重复的，可能会出现多个索引页的最小值是相同的(此时就需要依靠主键进行区分)，所以非主键索引的第一排序规则是这个name字段本身，而第二排序规则则是数据行的主键值，示意图如下 ：

![image-20210121103148753](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210121103148.png)

#### 索引的好与坏

索引本身是用来加快目标数据的定位工具，给常用字段加索引的确可以加快数据的查询速度，但是也不是索引越多越好。

首先，增加索引是一种典型的拿空间换时间的策略，表数据越多，那么添加的索引占空间越大，所以，建议多采用联合索引来降低空间占用率。

其次，增加索引过多会导致增删改的sql执行时长增加，因为除了要维护聚簇索引的数据页内容外，还要维护这些非主键索引的数据一致性和顺序性，无论是增加、删除还是修改数据，都需要从索引树的根节点一层层的遍历，定位，直到找到目标数据的位置后才能进行开始操作，增加的索引越多，这个过程花的时间也就越多。 

#### 联合索引原理

如果现在有一个学生用户表，这个表加了一个联合索引(index(class_name,age,name))，那么这个联合索引树的排序规则就是按照class_name，age，name依次排序，首先按class_name排序，如果class_name相同则按照age排序，若class_name和age都相同则按照name排序，若三个字段都相同则按照id排序。所以索引的示意图如下：

![image-20210121111202858](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210121111202.png)

现在要查询select * from student where class_name=a and age=12 and name=a的数据，那么mysql会根据这个where的条件判断这些条件可以使用联合索引进行查询 ，那么就会找到索引0，使用二分法进行查找class_name,age,name匹配度最高的记录，即索引1的记录行(class_name=a满足，age=10范围满足，name=a满足，而索引2在age=13就大于了查询条件了)，之后在索引页1中继续使用二分法进行查找，先匹配class_name选出一批数据，再这篇数据中再匹配age筛出一批数据，这样目标数据就定位在了id=4的索引记录上(若有多个记录则都记录)，拿到目标数据的id后就可以进行回表了，使用这个id去聚簇索引中查询完整 的数据行记录。



#### 查询匹配规则和分类规则

index(class_name,age,name)

| class_name | age  | name    |
| :--------- | ---- | ------- |
| 1班        | 8    | Alen    |
| 1班        | 8    | Beerror |
| 1班        | 8    | John    |
| 1班        | 9    | Arok    |
| 1班        | 9    | Blender |
| 1班        | 10   | Crry    |
| 2班        | 7    | Timmy   |
| 2班        | 7    | thomson |
| 2班        | 9    | Mike    |

在索引的使用中，并不是查询条件中有索引的字段就会生效索引的，合并是在联合索引中，一定要遵循最左原则才能保证索引被使用上，下面我们来了解一些索引匹配规则。

**等值匹配：**

在上述示例中，我们在查询条件全部使用了等号进行查询，这在查询匹配规则中是属于等值匹配，只要查询条件字段和索引字段一一对应就可以使用这个联合索引(查询条件顺序可乱)。

**最左列匹配原则：**

如果我们只使用联合索引的一个或几个字段进行查询那么就必须要按照索引的排序规则来一一对应

```sql
--  下面三种情况会使用索引 
select * from student where class_name=a and age=12 and name=a
select * from student where class_name=a and age=12
select * from student where class_name=a
--下面的情况不会使用索引
select * from student where age=12 and name=a
select * from student where age=12
select * from student where name=a
--下面的情况会使用部分索引(只会使用class_name的索引)
select * from student where class_name=a and name=a
```

**最左前缀匹配原则：**

在使用like关键字时，最好使用最左匹配，即‘内容%’的形式。这样可以和索引的排序对应起来

```sql
--  会使用索引 
select * from student where class_name like '1班%'
--  不会使用索引
select * from student where class_name like '%1班'
select * from student where class_name like '%1班%'
```

**范围查找原则：**

若要进行字段范围查询，在联合索引中有且只有第一排序字段(最左侧的字段)可以使用索引，因为相邻的索引页是由双链表进行连接的。

```sql
--  会使用索引 
select * from student where class_nam  > '1班' and class_nam  < '3班'
--  会使用部分索引(只会使用class_name的索引)
select * from student where class_nam  > '1班' and class_nam  < '3班' and age=12
```

**等值匹配+范围匹配原则：**

若是对于单个最左字段数据进行查询，则第二索引字段是可以使用范围查询的，因为单个的最左索引字段查询出的数据集中第二个索引字段是有序排列的

```sql
-- 会使用索引 
select * from student where class_nam = '1班'  and  age >8  and age <12 
```

#### 排序分类

在进行order by排序时，mysql如果没有使用索引，就会将查询的结果集放入一个临时内存区或临时磁盘区中，按照顺序排列好后才会输出结果，这样也会花费非常多分时间。

在联合索引中，表数据就是按照索引的一二三字段序列排好序的，如果order by刚好是按照联合索引的顺序来排列的话，那么查询出的结果集直接就是排好序的，不用来单独处理查询的结果集了，但是也有一点要注意，那就多字段排序时要么都是升序，要么都是降序，如果有升有降就 没法直接按照索引排序了。

---------

除了order by外，group by分类同样如此 ，如果不使用索引查询，就会将查询结果集放入一个临时内存区或临时磁盘区中，按照分类字段分类出一组组的数据，然后对每组数据 进行聚合查询得出 最终结果。如果group by的字段刚好是联合索引的字段，并且 顺序 一致，那么也 可以省去查询结果排序的过程。

#### 覆盖索引和前缀索引

有这样一种情况，就是我们要查询的字段信息刚好是联合索引中的字段，这种情况下是可以不用回表查询整个数据行信息的，这种查询通常耗时更短，被称为**覆盖索引**查询

对于text、varchar等长内容字段，如果需要加索引，最好是将字段的前几个字符作为索引即可，这种索引被称为**前缀索引**(前缀索引无法用于group  by)。

```sql
--  将city字段的前5个字符作为索引
alter table city_demo add key(city(5));
```

如果科学的选择前缀索引的长度可以参考：http://blog.itpub.net/30317998/viewspace-2654308/