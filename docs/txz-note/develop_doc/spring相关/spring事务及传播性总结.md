spring事务及传播性总结

### 一、事务概念及特点

#### 1.1事务概念

事务是进行数据操作和访问的基本程序执行单位，从代码的角度看就是从一个Connection的setAutoCommit(true/false)到Connection的commit/rollback的过程。

#### 1.2事务特点

事务有四大特点：

- **原子性**：事务的执行逻辑不可进行分割执行
- **一致性**：事务进行的数据操作要保证执行前后数据的一致正确，执行错误可以对事务操作进行回滚
- **隔离性**：事务和事务之间是相对独立的，无法相互干扰
- **持久性**：事务的执行对数据的改变是永久的



### 二、数据库中的一致性问题和事务隔离分级

#### 2.1数据一致性问题

数据库中事务的隔离性是有一定限度的，当数据的并发操作过多时会出现以下问题：

- **脏读**：事务B读取到事务A未提交的数据，而事务A回滚了数据，此时事务B的操作会导致数据不一致(解决方案：对事务进行加锁，保证一个事务提交后才能被另外一个事务读取)
- **不可重复读**：事务A中要进行两次余额查询，第一次查到余额数据X，此时另一个事务B修改了余额为Y，此时，事务A再次查询余额为Y，两次查询余额不相同(解决方案：对操作的数据添加行级锁，保证事务中数据不能改变)
- **幻读**：事务A中要进行两次数据总数查询，第一次查到X条数据，此时另一个事务B新增/删除了数据，此时，事务A再次查询总数时发下两次查询的总数不相同(解决方案：对操作的数据表添加间隙锁，保证事务中数据的总数不能改变)

#### 2.2事务隔离分级

对于以上问题，数据库都有一个数据隔离分级来解决这些一致性问题：

- **读未提交(read-uncommitted)**: 指能读取到其他事务没有提交的数据，不会产生脏写(不允许 多个事务同时操作同一个数据)；会产生脏读、不可重复读、幻读问题，一般不会使用此级别

- **读已提交(read-committed)**：指能读取到其他事务已提交的数据，会产生不可重复读、幻读；避免了脏读脏写(简称RC级别)

- **可重复读(repeatable-read)**：指事务之间互相隔离，一个事务读取的数据不会被其他事务改变，但是会读取到其他事务新增/删除的数据。会产生幻读；避免了不可重复读、脏读脏写((简称RR级别)

- **序列化(serializable)**：指事务串行化执行，避免了不可重复读、脏读和幻读，但是效率极低

多数数据库都默认采用**读已提交**或**可重复读**作为隔离方案，如Mysql默认为**可重复读(RR)**级别，而且mysql的RR级别还可以避免幻读，SqlServer和Oracle默认为**读已提交**级别

### 三、spring的事务隔离分级和事务的传播性

spring管理事务就是自动完成setAutoCommit(false)和Connection的commit/rollback的操作，用户只用关注业务即可。具体使用

@Transactional完成。

#### 3.1spring的事务隔离分级

spring的事务隔离级别和数据保持一致，一一对应：

- **ISOLATION_DEFAULT**：使用数据库默认的隔离级别，spring的默认隔离级别
- **ISOLATION_READ_UNCOMMITTED**：读未提交
- **ISOLATION_READ_COMMITTED**：读已提交
- **ISOLATION_REPEATABLE_READ**：可重复读
- **ISOLATION_SERIALIZABLE**：序列化(

#### 3.2spring的事务传播性

spring的事务具有一定的传播性：

- **PROPAGATION_REQUIRED：**外围环境存在事务就加入其中，没有事务则新建事务，spring默认事务传播性

- **PROPAGATION_REQUIRED_NEW：**新建事务，若外围环境存在事务则挂起外围事务，等当前事务执行完成后再执行外围事务；也就是和其他事务相互独立

- **PROPAGATION_NESTED：**外围环境存在事务就加入其中，没有事务则新建事务，但是若方法异常回滚，也不影响外围方法执行(和PROPAGATION_REQUIRED_NEW的区别是事务提交顺序问题，参考https://www.jianshu.com/p/f89771cae115)

- **PROPAGATION_SUPPORTS：**外围环境存在事务就加入其中，不存在就以非事务方式执行当前方法

- **PROPAGATION_NOT_SUPPORTED：**以非事务方式执行当前方法，存在事务就挂起事务

- **PROPAGATION_MANDATORY：**外围环境存在事务就加入其中，且强制使用事务，没有就抛出异常

- **PROPAGATION_NEVER：**以非事务方式执行，存在事务就抛出异常

  具体实例可参考：https://juejin.im/post/5ae9639af265da0b926564e7#heading-6
  
  https://blog.csdn.net/Vincent2014Linux/article/details/89669762
  
  