JVM-2(分代模型和内存设置)

### JVM分代模型和内存设置

#### 年轻代、老年代、永久代 

接上文示例，如果一个线程调用某个方法，方法区中的存在类实例对象的创建，那么这个对象会在堆内存中创建，并由虚拟机栈中的局部变量指向这个 堆中对象的地址。当方法执行完成后，局部变量倍销毁，这个堆中对象就变成了没被引用的垃圾对象，需要有内存回收线程销毁这个对象，示意图如下。

![image-20210204105710847](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210204105718.png)

那么垃圾回收的规则是怎样的呢？这就涉及到堆空间的分代模型了。首先，堆内存主要被分为了两个区域，一个是年轻代、一个是老年代；所有对象创建的实例对象一开始都会存放到年轻代的区域中，当年轻代的使用内存被用完时，再需要创建新的对象时就会触发年轻代的垃圾回收机制，年轻代的垃圾回收被称为Minor GC或者是Young GC，所以年轻代可能会比较频繁的触发内存回收，销毁其中没被使用的对象来腾出空闲空间来，所以年轻代的对象生存周期一般都比较短。

相比于年轻代中的对象，老年代中的对象往往生存周期更长，一般来说，在年轻代中进行垃圾回收时，需要判断这个对象是否被引用中，如果有变量指向这个对象，那么这个对象就不是垃圾，本次垃圾回收就不会回收这个对象；同时这个对象会有一个标记来记录自己经历过多少次垃圾回收，每经过一次回收且当前对象都没有被回收的话，这个标记就会+1，可以认为这个对象大了一岁。老年代如果内存空间也满时也会触发垃圾回收，一般称为Old GC。

当一个对象累计多少次垃圾回收都没有被回收，达到一个限度时(-XX:MaxTenuringThreshold配置参数)，就会将这个对象从年轻代移动到老年代，由于老年代的垃圾回收频次较低，所以这个对象会拥有更长的生存周期。

除了年轻代和老年代外，还有一个永久代，这个区域一般指的是JVM中的方法区(元空间)，里面存放的是类的Class对象和字节码信息等等，这些对象一般来说会一直存在，达到触发垃圾回收条件比较苛刻。

```java
永久代类回收条件
1.该类的所有类对象在堆空间中均已回收销毁
2.加载这个类的ClassLoader对象被回收
3.对该类的Class对象本身没有任何引用存在
```

![image-20210204114341110](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210204114341.png)

#### JVM常见配置参数

对于上面的JVM分代模型等各个区域的大小，其实都是可以通过JVM参数配置的，下面我们 来看几个常见的JVM参数：

```sh
-Xms：Java堆内存的大小
-Xmx：Java最大堆内存大小
-Xmn：堆内存中年轻代空间的大小(老年代=堆内存-年轻代大小)
-XX:PermSize：永久代大小
-XX:MaxPermSize：最大永久代大小
-Xss：每个线程的虚拟栈内存大小
================
jdk1.8版本后永久代的参数名称改成了：
-XX:MetaspaceSize 
-XX:MaxMetaspaceSize     
=================
一个手动配置参数列表如下：
-Xms512M -Xmx512M -Xmn256M -Xss1M -XX:PermSize=128M -XX:MaxPermSize=128M 
```

如何手动配置这些参数呢?

如果是使用eclipse/idea等开发工具，则可以在debug as的设置弹窗中设置VM参数(VM args)，如下面图是idea的JVM设置位置：

![image-20210204140930478](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210204140930.png)

如果是命令行执行jar包或war包，则可以在执行命令后添加这些参数：

```sh
java -Xms512M -Xmx512M -Xmn256M -Xss1M -XX:PermSize=128M -XX:MaxPermSize=128M -jar -App.jar
```

#### 评估线上JVM压力

分析一个系统的JVM压力，也就是分析JVM的参数需要配置成多少合适。下面以支付系统为例来分析下JVM的实际抗压能力。

首先，我们需要知道一个用户支付的大概流程，大概分为这么几步：

1. 用户在商城系统等应用中选择购买商品，发起支付请求
2. 商城系统会生成一个待支付订单，提交到支付系统中
3. 支付系统收起请求数据，会跳转到收银台请求展示给用户
4. 用户选择一种付款方式，确认支付成功，会再给支付系统的待付款订单发起确认请求
5. 支付订单确认支付后，会生成请求交给三方支付渠道处理订单
6. 确定账款支付成功后，会返回支付结果给用户

**那么支付系统的JVM压力在哪里？**

主要是堆内存中创建的多个订单支付类实例对象，在并发环境下，N个用户会在JVM的同一时间内创建N个支付对象，如果这个实例对象多到占用内存总和超过了年轻代的上限，就会频繁触发Young GC了。

![image-20210204142821096](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210204142821.png)

**到底同一时间会生成多少订单对象呢？**

我们以1天生成了100万支付订单为例，按照2/8定律，订单的80%，80万订单的生成时间主要集中在中午和晚上大概2个小时内，那么JVM的最大压力就是111(800000/2/60/60=111),也就是JVM每秒会创建111个订单支付对象。如果系统进行了负载配置，则压力还可以进行分担(111/负载系统数)

**每个订单执行需要耗时多长？**

一个用户从提交支付请求，到支付完成，那么JVM中就有创建一个支付订单对象，填充数据，到支付数据入库等等步骤需要CPU一步步的执行，我们可以假设一个支付请求在JVM中的大概耗时是1秒钟(一般是毫秒级别的)。

那么和之前JVM每秒创建(111个对象/每秒)的速率对应起来就是，JVM在一秒钟内创建了111个订单支付对象，并完成了支付数据入库等操作，之后这111个对象在堆中就成了垃圾会被回收掉，接着就是下一秒再来111个订单对象，再次循环这个过程。

**每秒生成的订单对象在JVM中占多大内存？**

这个其实可以用数据类型所占字节数进行大概的统计，如Integer变量是4个字节、Long变量是8个字节等等，我们可以初略 估计一个订单支付对象占用的内存是500字节，这样111个对象的大小大概是50000字节左右，也就是50K左右。但是这仅仅是支付订单生成的对象，实际上会有更多其他的对象在堆内存中创建，所以可以将这个计算结果扩大10~20倍左右，就是还有其他一二十中对象会同时创建。

综合算下来，一秒中内在堆中创建的对象大概是几百K~1M的大小，之前的计算结果代入这个公式得到结果是50K * 20  =1M左右，支付系统1秒钟在堆中会创建大概1M的数据

**多长时间会进行一次Young GC？**

接上文JVM一秒会创建1M的数据后，用户请求执行完成，这1M的数据 在堆中就成了垃圾。我们以2核4G的服务器为例，可以给堆内存设置1.5G的大小，其中-Xmn年轻代的空间可以给到750M大小，那么进行一次Young GC的时间大概是750/1=750秒，大概是12分钟。

#### 一个请求量暴增导致系统变慢宕机的案例

我们还以JVM中每秒生成1M的对象垃圾为例，如果请求量从每秒100个请求，暴增包每秒上千的的请求量，那么服务器的网络带宽、JVM内存、磁盘吞吐量、CPU负载、内存负载等压力会瞬间打满，由于请求过多，会导致每个请求的平均消耗时长变成，可能原本1秒就能执行完一个请求，在 请求占满的环境下可能需要5秒左右才能执行完，这就会导致JVM压力的进一步增加。

具体而言就是，堆内存的年轻代空间中会存在较长时间内(秒级别)很多还在使用的对象，也就是一次Minor GC并不能回收很多空闲空间，由于新的请求还有很多，还会创建更多新的对象，所以下一次Minor GC也会很快触发，这样的环境下Minor GC会在极短的时间内就执行很多次。

Minor GC执行多了就会将很多年轻代的对象移动到老年代中去，这样老年代的空间也会很快被占满，从而导致老年代也会频繁的进行Old GC，而老年代的GC回收速度是很慢的，这又会导致系统变得更慢，最终可能会致使系统宕机。

**所以主要问题在哪里？**

答案是年轻代的内存不足，不足以支持这么大的请求量。如果年轻代足够的大，那么每次Minor GC一定可以回收到足够多的空间，不容易导致下一次Minor GC很快的到来。

**如何设置永久代大小？**

一般设置个几百MB就足够了

**如何设置栈内存大小？**

一般设置在512k~1M就足够了