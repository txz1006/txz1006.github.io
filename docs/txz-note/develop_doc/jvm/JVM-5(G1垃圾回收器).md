JVM-5(G1垃圾回收器)

### G1垃圾回收器

在对内存的空间分配中，一般年轻代会通过Minor GC进行垃圾回收，老年代会通过Full GC进行垃圾回收，而且两种垃圾回收时都会进入stop the world状态，此状态下JVM会暂停堆空间的读写业务，也就导致了系统性能的抖动问题。此外，当Full GC的时间越长，对业务的影响也会越来越大，特别是堆空间本来就分配了较大内存的状况下。

所以，G1垃圾回收器就诞生了，他是可以避免Full GC时间过长的，因为G1垃圾回收器有一个特点，就是他可以控制垃圾回收时STW的时长。我们可以通过添加JVM参数**-XX:+UseG1GC**指定G1垃圾回收器。

#### G1垃圾回收器的应用场景

堆空间太大，导致一次Minor GC和Full GC的时间多过长导致系统性能抖动

#### 什么是G1垃圾回收器？

G1垃圾回收器内存空间和之前讲的堆空间结构完全不同，他不是在物理上将堆空间分为年轻代和老年代，所以我们需要抛弃掉之前堆空间的那套结构标准，以一个全新的视角来重新理解G1下的堆空间构成。

#### **1.G1下会将堆空间拆分为一个个的内存块(Region)**

![image-20210214150506889](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210214150515.png)

堆空间最多可以分配出2048个内存块(Region)，而每个Region的大小按照堆空间大小除以2048算(以4G堆空间为例，每个Region的大小是4096/2048=2M)，当然也可以通过配置参数**-XX:G1HeapRegionSize**手动指定Region块的大小。

#### **2.G1垃圾回收可以控制垃圾回收时长**

G1在垃圾回收时，可以预先指定垃圾回收的时长，也就是说可以指定JVM进入STW状态的时长。这个参数是**-XX:MaxGCPauseMills**，默认是200ms，他的逻辑大概是这样的：G1会使用算法估算每个Region中垃圾回收所需的时长，比如Region A中有10M的垃圾，回收需要500ms, Region B中有20M的垃圾，回收需要200ms, G1判断出Region B的回收时长大概是JVM最大暂停时长，那么在下次G1垃圾回收中会优先回收Region B中的垃圾。或者多个Region的垃圾回收时长之和等于 200ms左右，那么也会回收这些Region中的垃圾。

简单的说就是在指定垃圾回收的时长下，尽量回收多的垃圾。

#### **3.G1回收垃圾方法**

当G1进行垃圾回收时，使用的复制算法，也就是对某个Region进行垃圾清理时，会将这个Region块中的存活对象赋值到其他的空Region中，然后清空这个Region。

#### **4.Region 可能属于新生代，也可能是老年代**

使用G1垃圾回收后，堆空间只在逻辑上区别年轻代和老年代，在实际内存分配中不再进行固定的新老代的划分。也就是每个Region块可能属于年轻代，也可能属于老年代，比如一个Region块首次打上了年轻代的标签，用来存储年轻代对象，那么在这个Region被垃圾清理后，可能又会被打上老年代的标签，用来存储长时间存活对象。

![image-20210214154450308](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210214154450.png)

#### **5.Region块的分配**

使用G1垃圾回收器的堆空间默认会分配5%的内存用来创建新生代Region块，以4G内存为例，也就是200M左右的内存，创建大概100个Region块(80个eden区的块，20个s区的块)，这个5%的比例可以通过**-XX:G1NewSizePercent**，手动配置。

随着新生代对象的增多，JVM还会创建更多的Region来作为新生代对象的存储空间，新生代对空间最大总和不超过堆内存的60%，可以通过**-XX:G1MaxNewSizePercent**参数配置最大堆内存比例。通过这个比例我们也知道在G1下老年代的比例是40%(老年代内存块可以超过40%的占比)。

当60%的新生代中eden区的region块空间全部用完时，会触发新生代的GC。

在原来的年轻代空间的分配中，有个参数**-XX:SurvivorRatio=8**，将年轻代分为Eden区和Survivor区，那么用在G1中的 Region块中，4G内存初始的100个Region块中，那么Eden区的Region区大概有80个，而Survivor区的Region块大概有20个上下，这个数量也会随着系统的运行会不断增多。

如果一个对象占用的空间过大，那么就会横跨多个Region来共同存储这个大对象，这些Region属于大对象Region，不属于新老代Region。

![image-20210214162115877](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210214162115.png)

所以，Region块的所属区是会不停变化的，可以是Eden区的块，可以是Survivor区的块，还可能是Old区的块。整个堆空间的Region块都是动态的，而Region块的垃圾回收也不区分新老代了，也就是年轻代和老年代的垃圾一起清理。在G1的专有名称是Mixed GC。

#### **6.G1下对象进入老年代的条件**

和非G1下的固定堆空间的条件基本相同。

1.年轻代对象存活年龄达到设置上限

2.某次GC后年轻代存活对象超过S区上限的50%

触发Mixed GC的条件：

1.G1有个参数**-XX:InitiatingHeapOccupancyPercent**，默认值是45%，作用是如果老年代占当前全部Region块的45%，那么就会触发这个Mixed GC。

#### **7.G1垃圾回收的步骤**

G1的Mixed GC垃圾回收和老年代的垃圾回收很像，有以下几个步骤：

1.初始标记

进入STW状态，标记下GC Roots能直接引用的Region中的对象。

![image-20210215145328379](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210215161246.png)

2.并发标记

解除STW状态，对第一阶段初始标记的对象进行GC Roots追踪，将Region中的存活对象进行标记。

3.最终标记阶段

再次进入STW状态，根据并发标记结果确定哪些对象是存活的，哪些对象是垃圾

4.混合回收阶段

这个阶段会计算老年代中每个Region中存活对象的占比，和预计垃圾回收时间。我们知道G1设置了一个每次GC的执行时间上限，默认是200ms；那么这个阶段就会在新生代和老年代选出一些垃圾占比较高的Region块，当这些Region块的预计执行时间合计差不多是200ms时就会回收这些Region块。

#### 8.G1垃圾回收参数

在垃圾回收的混合回收阶段会回收执行时间是200ms左右的Region块，但是这一次垃圾清理多半是清理不完的，所以G1会分多次垃圾回收来清理所有的垃圾，这个有一个参数**-XX:G1MixedGCCountTarget**，他指定了最后的混合回收阶段可以分段执行GC的次数，默认值是8次。

比如一次Mixed GC预计回收160个Region块，那么就会分8次GC，每次GC清理20个Region块。这样空出来7次空闲间隙就可以进行其他业务的执行。

还有一个参数**-XX:G1HeapWastePercent**，默认值是5%，也就是在Mixed GC的8次垃圾回收中，如果前几次GC中清理出空Region块占到了全部Region块的5%，那么这次混合回收就结束了。

此外，并不是有垃圾的Region块都会被选中GC，有个参数**-XX:G1MixedGCLiveThresholdPercent**，默认值是85%，也就是一个Region块中的垃圾占比达到85%时才会被选中为清理目标。

#### **9.Mixed GC失败时会触发Full GC**

如果在使用复制算法进行Region块垃圾回收时，没有空闲的Region块用来存放存活对象，那么就是Mixed GC失败了，此时会触发Full GC，JVM会进入STW状态，使用Serial Old垃圾回收器，单线程进行进行标记、清理和压缩整理，空闲出来一批Region块，当然这个过程非常的缓慢。

#### 10.G1参数优化实例

G1下新生代GC并不是需要等到堆内存被新生代占到60%后 才会GC，也不是默认的5%Region块被占完时就会GC。他会动态的计算当前新生代所有Region块清理的语句时长，当时长达到200ms左右就会触发一次新生代GC，当然这个时间也是预估的

那么-XX:MaxGCPauseMills参数的设置就尤为关键了，设置小了年轻代会频繁GC，导致更多的对象进入老年代Region块中，设置大了会造成年轻代GC时间过长(STW时间过长)，存活对象太多S区Region装不下，也会进入老年代Region块中。由于老年代Region的增多，从而导致Mixed GC频繁发生。