JVM-3(堆内存垃圾回收原理)

### 堆内垃圾回收原理

在上文中，我们知道堆内存分为了年轻代和老年代两部分，而且年轻代满时会触发Minor GC清理年轻代的垃圾，老年代满时会触发Old  GC清理内存。

![image-20210204114341110](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210204114341.png)

#### 什么对象可以作为垃圾回收

既然堆空间用尽时触发垃圾回收，那么如何判断哪些对象变成的垃圾？或者说哪些特定的对象是可以回收的？这要从两个方面说起：

##### 一、没有被引用的对象可以回收

正常的对象调用必然是在栈中有一个引用变量，这个对象指向堆内存中某个对象的地址，这样通过引用变量就可以操作对象了，示意图如下：

![image-20210206160218351](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210810155315.png)

如果引用变量所在的方法生命周期执行完成后，那么这个引用变量就会被销毁，那么堆内存中的对象就会少一个引用，当对象一个引用都没有时，这个对象就成了被回收对象。

所以这里要引出一个概念，在JVM中判断堆中对象是否还在被引用是通过一个可到达性算法(GC Roots)实现的，即JVM会在垃圾回收前调用这个算法，来判断一所有对象是否有局部变量、静态变量指向，没有就 可以回收，有就不能回收这个对象。

##### 二、弱引用、软引用、虚引用在满足条件是可以回收

除了对象没有引用时会被回收的条件外，还有一些其他条件会让JVM回收一些还存在引用的对象。这里就需要提到变量引用的分类了，在Java中引用类型可以分为四类：强引用、软引用 、弱引用和虚引用。

**强引用：**一般来说我们创建的静态变量、局部变量、成员变量都算是强引用，通过强引用指向的堆中对象只有强引用主动放弃指向堆对象时，且堆对象没有其他引用时会被回收。

**软引用：**通过SoftReference包裹目标对象实现的软引用，一般来说软引用对象不会被强制回收，但是当经历过一次垃圾回收后，发现内存依然不够，那么就会强制性将软引用指向的对象回收掉，无论这个对象是否正在被使用。(这类对象一般要经常判断是否为null)

```java
SoftReference<String> stringSoftReference = new SoftReference<String>(new String("123"));
String  temp = stringSoftReference.get();
```

**弱引用：**通过WeakReference包裹目标对象实现的弱引用，在每次回收垃圾过程中，无论这个对象是否正在被使用，弱引用对象都会被直接回收掉(可用于简单的缓存机制，缓存时长由JVM垃圾回收周期来定)

**虚引用：**使用PhantomReference对象包装目标对象，和弱引用类似，但是总是返回null，应用场景不多，可以 用于堆外内存释放，和垃圾回收跟踪(必须和ReferenceQueue队列联用，当一次GC要回收虚引用对象是，就会将这个对象引用加入到引用队列中，这样我们可以通过引用队列中判断是否有虚引用，在GC前采取一定的行为)，如 ByteBuffer.allocateDirect(1024 * 1024 * 5)直接内存对象，就是使用虚引用进行堆外空间释放的(详见sun.misc.Cleaner类)。

```java
//-Xmx10m -Xms10m只有10m的内存   
public static void main(String[] args) throws InterruptedException {
        ReferenceQueue<byte[]> queue = new ReferenceQueue<>();
        // 虚引用必须要和引用队列一起使用，他的get方法永远返回null
        PhantomReference<byte[]> phantomReference = new PhantomReference<>(
                new byte[1024 * 1024 * 5] , queue);
        System.out.println(queue.poll()); //null
	//gc后phantomReference对象的引用会被放入queue队列中，只有指向phantomReference对象的引用都丢失了才会gc虚引用指向的对象
        System.gc();
        
        Thread.sleep(300L);

        Reference poll = queue.poll();
        System.out.println(poll);  //phantomReference对象的地址
       // 根据JDK8的api文档介绍，将所有这样的引用被清除或者自身变得不可访问，GC才会回收
        poll = null;
        phantomReference = null;
		//下次申请内存发现空间不够了，成功删除上面虚引用指向的5m的内存
        byte[] bytes = new byte[1024 * 1024 * 6];
    }
```

其他应用：

```
对象：weakHashMap
weakHashMap使用了弱引用作为键值对的Key，所以该对象的Key存活周期较短，在每次GC时会清理掉该对象的Key值引用，同时也会删除与之对应的Value值，这个对象可以用来作非重要数据的内存缓存，缓存清理由GC周期而定
```



#### 年轻代堆内存如何回收垃圾

知道哪些堆是可以回收的后，下面我们就详尽的了解下垃圾回收的方式，从年轻代开始。

首先，我们来说一种错误的内存回收机制，即当年轻代的内存用尽时，JVM会依次扫描内存中的对象，通过RC Roots算法判断这个对象发生还有引用，没有就直接回收掉这个对象，然后依次循环。

这种回收机制的最大问题就是会造成很多的内存浪费，因为对象在堆中的位置是不一样的，按这种方式回收的空间会十分的分散，不是一块连续可用的内存区域，示意图如下：

![image-20210206163825575](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210206163825.png)

这种回收机制需要优化，给我们清理出更多连续可用的内存才是最好的。所以JVM中实际采用一种复制算法来实现一种清理空间不分散的机制。简单的说就是，将对内存分为两块，一块主存储，另一块主备份，创建对象时在主存储块中进行，主存储块用完时，将非垃圾对象依次复制到另一款备份区域，然后清空主存储区域，并调换两个内存区的身份，示意图如下：

![image-20210206164822307](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210206164822.png)

当然这样的机制时不能直接使用的，因为这种方式的实际内存使用率只有50%。所以，在堆空间的年轻代区域采用的是**复制算法**的优化方案：

将年轻代区域分为三块区域，分别是Eden区和两个Survivor区(S区)，默认内存分配比例是8:1:1，也就是1个G的年轻代内存，Eden区是800M，两个Survivor区分别是100M，示意图如下：

![image-20210206173110841](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210206173110.png)

这样正常创建对象都使用Eden区，当Eden区域用完时，将非垃圾对象复制到一个S区(Survivor from区)中，然后执行Minor GC清空Eden区域；当Eden区二次用尽时，会将Eden和Survivor from两个区的非垃圾对象复制到另一个Survivor区(Survivor to区)中，同时清空Eden区和Survivor from区，之后Survivor from区和Survivor from区身份调换，再次循环这个过程。

这样整个年轻代的空间使用率就有90%，只有一个10%的Survivor区会一直空闲。

#### 年轻代对象进入老年代区域的条件

我们之前提到过，如果年轻代中如果有对象在经历15次垃圾回收还存活，那么这个对象就会被提到老年代中，下面我们来聊一聊年轻代中对象进入老年代的条件。

1. 对象经历15次垃圾回收 还存活(这个次数可以通过-XX:MaxTenuringThreshold参数配置)
2. 在Minor GC中，年轻代中存活对象的总和大小超过了某个Survivor区的50%，那么在下次Minor GC中会将存活对象中存活年龄最大的一批对象移到老年代中(如年龄1+年龄1+...+年龄N存活对象中,从年龄0开始往年龄大的遍历，依次相加对象大小之和达到50%后(此时遍历年龄为3)，将最后年龄大于等于3的一批对象转移到老年代)
3. 创建的实例对象大于-XX:PretenureSizeThreshold配置参数(默认值是0，意为所有对象都创建在年轻代)时，直接在老年代创建，不经过年轻代。
4. 若Minor GC后的存活对象总大小大于了某个S区的总大小，则直接将这些存活对象移入老年代(Minor GC前 需要进行空间担保，可能这批对象的大小也会大于 老年代剩余空间)

##### **空间担保细则**

在进行Minor GC前，JVM会检查一下老年代剩余最大连续空间是否大于年轻代所有对象的总和大小，这个判断就是空间担保，如果老年代空间不够，则会直接执行老年代的Full GC，然后在执行Minor GC;如果设置了HandlePromotionFailure参数的话，还会进一步判断当前老年代最大连续可用空间是否大于历次进行老年代的对象平均大小，如果满足条件则会冒险先执行Minor GC，GC后如果年轻代的存活对象大小还是大于S区上限，而且也大于老年代的最大连续空间，那么会执行Full GC来清理老年代的垃圾，清理过后若空间足够了那么就把年轻代所有的存活对象移到老年代来，如果还不够就会触发OOM。

![image-20210207160053478](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210207160124.png)

但是在JDK 6 Update 24之后，HandlePromotionFailure参数废弃 失效了，而且空间担保规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。

![image-20210207175338864](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210207175338.png)

##### 标记整理算法

老年代的的垃圾清理算法是**标记整理算法**，简单的说就是，在一块内存区域中将还存活的对象进行标记，标记后将这些对象移动到老年代的一个片区依次紧密排序，然后将垃圾对象清理掉。由于涉及内存地址的转移，所以老年代的GC是非常慢的，性能比年轻代GC差10被以上。

#### 垃圾回收状态"stop the world"

在进行垃圾回收时，JVM会进入stop the world状态，就是该状态下堆内存是不能写入新对象的，等到垃圾回收完成，才会恢复堆内存操作权。

所以 stop the world是JVM最大的问题之一。

只能通过尽可能快的垃圾回收算法来缩短stop the world状态的时间，比如常见的年轻代垃圾回收器是ParNew算法，他支持多线程回收垃圾机制；老年代垃圾回收器是CMS算法。



#### 一个堆空间优化案例

现在有一个系统需要接受上游其他请求的数据，每分钟大概执行500次请求，一次请求需要处理10000条数据(即在内存中创建1万个对象)，执行时间是10秒钟。系统分到了5台服务器(4核8G)做负载均衡，也就是每分钟每台机器的请求大概减到100次请求左右；服务器对于JVM是统一配置的，都是堆空间分配了3个G，其中年轻代和老年代各1.5G。

现在问题来了，**新生代进行一次GC的周期大概多长？**

年轻代是1.5G，按照E区和S区8:1:1的比例来算，E区的大小是1.2G左右，S区每个150M上下。然后我们来算下10000条 数据能占多少内存，我们简单估计以每个支付对象占500字节的大小来算，10000个对象大概是5MB，这是一次请求产生的数据量。上面的数据中提到每分钟100次请求，则每分钟会占用500M的E区空间，这样大概2分钟左右就会把E区内存用完，然后进行GC。

**年轻代一次GC会回收多少内存？还剩余多少对象存活？**

由于一次请求需要10秒来执行，两分钟能执行大概200次请求，我们按2/8定律假定有160个请求已经执行完成，还是40个请求正在执行中，那么就有200M的数据会在一次年轻代GC中存活，回收大概1G的空间。由于200M是大于一个S区的大小的，所有这200M数据会直接进入老年代中。

![image-20210209104525404](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210209104532.png)

**经过多长时间，老年代会被用完？**

按照每两分钟进入老年代200M的数据算，在6分钟时会进行第三次年轻代GC前会进行空间担保，因为此时E区1.2G空间被占完，而此时老年代在经历过两次年轻代的GC还有1.1G的大小，但是新生代1.2G的对象大小大于老年代1.1G的大小，如果设置HandlePromotionFailure参数时，判断历出进入老年代的平均对象大小200M小于老年代1.1G的大小，所以年轻代冒险GC，发现GC后又产生200M数据进入老年代中。

大概7分钟左右老年代就用了1.4G左右，无法支持下一次的年轻代GC了。

**多次时间触发一次Full GC？**

由于 大概7分钟左右老年代就用了1.4G左右，所以大概8分钟左右会有执行一次Full GC，假定老年代的对象都可以被清理，那么大概每7、8分钟就会执行一次Full GC，由于Full GC性能很差，所以这个频率会严重影响系统整体性能。

**如果进行JVM优化？**

本案例中应该尽量减少年轻代存活对象进入老年代的机会，所以，最好的办法就是增大S区的大小，我们可以重新分配年轻代和老年代的比例，可以改成年轻代2G(E区1.6G，两个S区200M)，老年代1G，或是改变E区和S区的占比，让S区可以容纳下一次Minor GC后存活对象的大小。这样无论是年轻代的GC或是老年代的GC频次都会减少。