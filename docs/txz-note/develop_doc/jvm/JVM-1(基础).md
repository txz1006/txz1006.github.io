JVM-1(基础)

### JVM简述

java是一门编译型(直接编译成机器指令执行)和解释性(通过解释器直接执行)共存的语言，首先java代码需要编译成.class字节码文件，没有编译过的java代码没法直接运行；其次，字节码文件并不能直接被CPU直接读取执行，需要被JVM虚拟机加载后进一步解释成CPU可以读取的机器指令。

所以JVM对于java来说是非常重要的，我们知道java代码可以一次编译，到处运行，对应到这个过程中就是就是JVM来兼容各种不同的操作系统，而java字节码文件则是统一标准可以被JVM加载执行。

所以JVM非常重要！ 

#### JVM如何加载一个Class文件

我们先来初步了解下JVM加载java代码的过程：

![image-20210202155415032](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210202155427.png)

主要有三个过程：

1. java代码通过javac命令遍编译代码成字节码文件
2. JVM提供有类加载器，通过双亲委派机制选择一个类加载器将字节码文件加载到JVM中
3. JVM会通过验证->准备->解析->初始化四个过程将类加载到JVM的内存中，之后就可以使用这个类了

##### 验证阶段

这是JVM处理字节码文件的第一个阶段，也就JVM会检查这个字节满文件是否符合标准，是否被篡改，是否能被加载等条件。

```
如果class文件不想被反编译，可以使用一些工具对class文件进行混淆或加密
```

##### 准备阶段 

验证完成后，JVM会根据这个类的成员变量、成员方法等组成成分划在JVM中分配内存区间，并会给变量一个初始值，如int变量会赋值一个0

##### 解析阶段 

将符号引用转化为直接引用

##### 初始化阶段 

会执行类的初始化函数或方法，如对static静态变量进行初始化赋值，自动调用static代码块等等。

```java
public class DEMO{
	private static int str = Driver.getNum();
    static{
    	//业务代码
    }
}
//需要注意的是，普通成员变量的初始化会在对象实例时才会触发执行。类加载时这里执行的是static静态类变量、静态类方法、静态代码块。
```

初始化触发的条件是要么创建一个类的实例，要么是 这个类有mian()方法，都会马上对类进行初始化 

##### 双亲委派机制是怎么样的？

JVM提供了三个ClassLoader对象：

Bootstrap ClassLoader：启动类加载器，负载加载jre/lib下jar包中的字节码文件，属于java系统类

![image-20210202161926828](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210202161926.png)

Extension ClassLoader： 扩展类加载器，负载加载jre/lib/ext下jar包中的字节码文件，属于扩展java系统类

![image-20210202162003245](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210202162003.png)

Application ClassLoader：应用类加载器，通过ClassPath加载开发者自己写的业务字节码文件，我们一般都使用这个类加载器

三个类加载器的关系构成了双亲委派，简单的说就是，应用类加载器加载一个类时，并不会直接自己加载，而是会将这个类信息传递给扩展类加载器，扩展类加载器拿到类信息后也不直接加载，而是将类信息交给启动类加载器，启动类加载器会根据类路径判断这个类是否处于自己负载的加载范围(是否是java   源码jar包中的类)，是则加载自己负责范围内的这个类，不是则让扩展类加载器进行判断，如果扩展类加载器发现这个类也不属于自己的加载范围，会最后让应用类加载器来加载这个类。

##### 双亲委派的好处？

在类名重复的情况下优先加载JAVA自身源码中的系统类

```
注意，有些业务场景需要打破双亲委派机制才能实现，例如tomcat的自定义类加载机制
```

![image-20210203162909337](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210203162909.png)

##### JVM什么时候会加载一个类？

在一个类被使用(调用)时，会将这个类加载进JVM。简单的说就是，我们将Demo.class类加载进JVM后，会找到main()方法开始执行，将其中其他java类加载到JVM中，然后进行调用。

或者我们new DEMO()直接new一个类实例时，会直接触发这个类的加载到初始化全流程。

需要注意的是如果加载的类有父类存在，则会先加载和初始化父类后，再加载当前类。

#### jvm的内存区域划分

下面我们来讲解一下JVM中的一些存储容器 ，也就是代码执行的过程中，类信息、实例、变量分别存放在什么地方。

首先，我们通过类加载器将字节码信息加载到JVM后 ，肯定需要将类信息存储到一个地方，这个地方一般是方法区或元空间(jdk1.8后改名为MateSpace)。

其次，在执行代码时，需要有能记录代码执行指令行位置的地方(记录代码执行的位置)，这个地区是程序计数器；此外，执行方法时，对于方法区中的临时变量也需要有地方能够存储，这个地方是java虚拟机栈。

最后，还有我们创建的类实例，这一类数据是统一存放在堆内存中的。

```java
public class Demo  {
    private int num  =  0;
    public static void main(String [] args){
        sout();
        Demo demo = new  Demo();
        int temp =  3;
        demo.num = temp;
        
    }
    
    public void sout(){
        int c = 1;
        System.out.println("信息输出");
    }
}
```

我们以上面 的Demo类作为例子，来详细说明一个类是如何存储在JVM这些容器中的。

Demo.java通过jdk编译，生成Demo.class字节码文件。之后通过Application ClassLoader加载进JVM；到JVM后这个Demo类会被存放到方法区中，注意方法区中还会存放常量池一类的其他东西，并不是只存放类信息。

紧接着，我们要执行Demo类的man方法，则会有一个main线程来读取字节码文件中的main方法中的地址指令，这些指令会通过字节码执行引擎进一步转换成硬件设备可以读懂的机器语言来执行。在执行这些指令时，需要有一个程序计数器来记录main线程当前执行字节码的位置，也就是执行到了哪条字节码指令了。

有了程序计数器后，开始一行行的执行字节码指令，由于方法的执行是可以嵌套进行，而且每个方法中有可以有局部变量等信息存在，所以执行线程除了有程序计数器外，还会有一个虚拟机栈存在，没执行一个方法，就会向栈中压入一个方法对象(栈帧)，这个栈帧包括局部变量表、操作数栈、动态链接、方法出口等东西，等到方法执行完成就会出栈释放内存。以上面的Demo类为例，main线程会将main()、sout()依次入栈执行，示意图如下：

![image-20210203152829622](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210203152829.png)

在执行main方法中，还会创建一个Demo类实例对象，由于Demo类之前已经被加载到JVM了，所以可以直接到方法区读取Demo类信息在堆内存中创建一个实例对象，然后会在虚拟机栈中创建一个demo指针，指向堆内存中的Demo实例 。

程序计数器和线程时一一对应的，java是支持多线程编码的，所以每一个线程都会关联一个程序计数器和一个虚拟机栈对象，多个线程就会有多个程序计数器一个虚拟机栈，整体示意图如下：

![image-20210203144920640](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210203144940.png)

#### jvm垃圾回收机制

以上面的Demo类main方法为例，main线程的虚拟栈中会创建一个demo局部变量，引用指向堆内存中的Demo实例。但是如果main方法执行完后，main方法的栈帧会从虚拟栈中出栈，也就是demo局部变量被销毁了，但是堆内存中的Demo实例也没有销毁，但是也没有其他引用指向这个实例了，这种情况下，这个Demo实例就成了垃圾。

所以，JVM提供了一套垃圾回收机制，来销毁这些没有引用指向的对象实例。

