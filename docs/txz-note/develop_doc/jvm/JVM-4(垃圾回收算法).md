JVM-4(垃圾回收算法)

### 垃圾回收算法

**Serial和Serial Old垃圾回收器：**分别回收年轻代和老年代的垃圾对象

由于 是单线程机制，所以在垃圾回收过程中会进入stop the world，效率较低，现在多不再使用。


**ParNew和CMS(Current Mark Sweep)垃圾回收器：**现阶段使用较多的年轻代和老年代垃圾回收器，使用多线程机制，回收效率高，多在生产中使用

**Parallel Scavenge和Parallel Old垃圾回收器**：和ParNew类似，使用复制算法的回收器。特点是会根据系统吞吐量来控制GC暂停的时间，而且可以根据系统运行状态自行调节各分代空间的大小，也是jdk1.8默认的垃圾回收器，常见的配置参数如下：

```java
-XX:+UseParallelGC    ##开启Parallel收集器+老年代串行
-XX:+UseParallelOldGC ##开启Parallel收集器老年代并行逻辑
    
-XX:MaxGCPauseMillis  ##控制GC暂停的时间(大于0，如果设置的很小，那么新生代会空间被调整的很小，GC时间变短了，但是GC的频率就上升了)
    
-XX:GCTimeRatio   ##控制GC暂停的时间占吞吐量的比例(如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即1 /（1+19）），默认值为99，就是允许最大1%（即1 /（1+99））的垃圾收集时间。)

-XX:+UseAdaptiveSizePolicy  ##这个配置会开启JVM自适应调整，即动态调整新生代大小及比例等参数，以提供最合适的停顿时间或者最大的吞吐量    
```

**G1垃圾回收器：**使用Mixed GC统一回收年轻代或老年代的垃圾回收器

如果你想要最小化地使用内存和并行开销，请选Serial GC；
如果你想要最大化应用程序的吞吐量，请选Parallel GC；
如果你想要最小化GC的中断或停顿时间，请选CMS GC。

参考：https://www.cnblogs.com/yanl55555/p/13365572.html

#### **年轻代Minor GC时的ParNew垃圾回收器**

ParNew算法就是年轻代中的垃圾回收器，当Eden区满后，JVM就会进入STW状态(stop the world)并触发这个算法的执行。

ParNew算法是多线程垃圾回收器，Serial算法是单线程垃圾回收器，两种方式的核心算法相同。一般在单核CPU下两种算法效率是一般无二的，只有在4核8G以上的配置才能凸显ParNew的优势。

ParNew算法的执行线程数默认和CPU核数相同，如4核8G机器会开启4线程进行垃圾回收，当然也可以通过配置参数**-XX:ParalleelGCThreads**自定义线程数

JVM有客户端模式核服务器模式，一般服务器端使用G2编译器，启动会慢一些，但是偏向于多线程处理数据，多用于非桌面操作系统使用，这样的操作系统多是多核CPU，使用ParNew算法能最大发挥多线程优势。

而客户端模式，使用G1编译器，启动会快一些，偏向于占内存少的桌面 应用程序设计，多在windows等桌面操作系统中使用，由于这样的操作系统多是单核CPU，使用Serial单线程可能会更好一些，多线程反而会因为频繁的进行线程切换反而效率不高。

**如何开启客户端模式或服务端模式？**

在启动项目时加入配置参数**-server**或**-client**，那么启动的就是服务器模式/客户端模式。一般默认情况下默认的是服务端模式，可以在jre\lib\amd64下查看jvm.cfg配置文件进行查看：

![image-20210209170912145](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210209170912.png)

想要默认启动是客户端模式，需要调换下这两个配置的配置即可。

#### **老年代Full GC时的CMS垃圾回收器**

对于老年代的垃圾清理，触发Full  GC时一般采用CMS算法，也就是标记清理法。简单而言就是先对老年代的垃圾对象进行标记，之后一起销毁，而且销毁后还会进行内存碎片空间压缩处理。

在整个CMS过程中，其实并不是和ParNew算法一样整个过程都进入STW状态的，而是分为好几个阶段只有其中几个步骤需要在STW状态执行而言，正是这种特点，这也能让老年代可以同时进行对象创建和垃圾回收。

大体上来说，CMS算法过程可以分为4个阶段，分别是：

1. 初始标记
2. 并发标记
3. 重新标记
4. 并发清理

我们一个个来细说，先说初始标记 阶段，这个阶段会**标记下GC Roots能直接关联到的对象**，具体而言就是局部变量、静态变量直接指向的对象，这个过程进行时是会STW的。

下一个阶段是并发标记标记阶段，这个过程中STW会结束，也就是这个过程中可以有新的对象进入老年代中，所以垃圾清理和对象写入同时进行。并发标记是指会多线程从GC Roots开始追踪，对老年代中的所有对象进行细细标签(这个过程最耗时)，检查标记每个对象是有GC Roots直接或间接的引用(存活)，还是没有引用变成垃圾对象。由于过程中一直会有新的对象进入老年代，所以一定会有新进入的对象没有被判断标记。

```java
public class Father{
	private static Son  son = new Son();
}
public class Son{
    private Apply apply = new  Apply();
}
如上面的类关系中，new Son()由于被一个静态变量指向，所以一定会老年代中存在。而静态变量son可以认为是一个GC Roots，在老年代进行CMS的初始标记阶段，就会将new Son()对象标记出来(存活对象)，而new Son()对象中的new Apply()对象，则可以认为是由son的GC Roots间接指向，所以new Apply()对象也会存在在老年代中，而且会在并发标记阶段被GC Roots追踪到这个对象被new Son()对象持有，所以是存活对象。
```

在经过并发标记后，老年代的大多数对象都已经被标记成存活或垃圾的标签，只有也新进入的对象是没有被标记检查的，所以会开始第三个阶段，也就是重新标记，将这些没有被标记的对象进行遍历标记一遍(也会从GC Roots出发，标记上成存活或垃圾标签)，过程中会进入STW状态，停止新对象进入老年代，由于这些对象只是少数，所以速度会很快。

最后，再次结束STW状态，进入并发清理阶段，由于也是和对象写入并发进行，所以非常耗时，这个过程会多线程的将之前标记的垃圾对象进行销毁清理。而新进入老年代的对象也分为存活和垃圾两种对象，而其中的垃圾对象又称为**浮动垃圾**，需要等到下一次Full GC才会被清理掉。

##### concurrent mode failure问题

由于老年代在进行垃圾清理中也会又新对象进入其中，所以实际上老年代的Full GC并不是要等到老年代的 空间彻底用完才会触发，而是设置留有一小部分的空闲空间来接受Full GC中也可以写入新对象。所以实际上有一个配置参数，用来限制当老年代空间使用达到多少时会触发Full GC，这个参数是-XX:CMSInitiatingOccupancyFaction=92，默认设置的值是92%，也就是始留有8%的空间用于新对象写入。

 -XX:+UseCMSInitiatingOccupancyOnly 只是用设定的回收阈值(上面指定的92%),如果不指定,JVM仅在第一次使用设定值,后续则自动调整.

但是如果在CMS过程中，进入老年代的对象大于了这8%的空闲空间，那么就会触发concurrent mode failure，导致的结果是JVM会更换老年代的垃圾回收算法为Serial Old垃圾回收器，也就是进入STW状态，重新对老年代中所有对象进行GC Roots追踪标记，标记出所有垃圾并清理完成后才会恢复系统工作线程。

##### **老年代内存碎片问题**

在进行完Full GC后，一般还有一个压缩存活对象的占用位置过程，也就是释放出更多的内存碎片来。

这个过程有个参数控制：-XX:+UseCMSCompactAtFullCollection(默认开启)，意思是在Full GC后再次进入STW状态，将存活对象对齐到一边，空出大片的连续 空间出来。

和这个参数搭配的还有一个参数-XX:CMSFullGCsBeforeCompaction(默认为0)，意思是执行多少次Full GC后进行内存整理，默认是0代表每次Full GC后都会进行整理。

#### 案例：配置生产环境的JVM参数

请求上亿的电商系统，每天日活500万用户，每个用户访问系统20次算，如果按照10%的比例转化率，那么 会有50万用户下单支付，而且这50万订单主要集中在每天4个小时的高峰期完成，大概的JVM负载是500000/4/3600=34订单/每秒，如果再负载均衡下就会更少了(这里按照10台机器负载算，那么每台机器每秒大概是3，4个订单)。

现在如果按照抢购大促活动的高访问量来算，每秒的下单量增加100倍，每个订单按照1Kb算，那么每秒钟会占用 300Kb左右的堆内存，这仅仅只是下单的对象占用空间。连带上商品信息、库存、优惠券等等关联信息，我们将这个数值扩大10~20倍。

此外，除了订单业务外，还会有其他的订单查询、分类秒杀等等 业务对象也存在，我们 需要将这个数值再扩大10倍，也就是300K * 20  * 10  = 60M左右，每秒中使用60M的年轻代空间。

**内存分配和参数配置**

假设我们现在有4核8G的机器，那么 可以分配给堆空间3G，其中年轻代核老年代各1.5G，加上永久代的256M，和几百兆的线程空间，和栈空间的1M大小，4G内存就分的差不多了。

这样我们就可以设置参数为：

```java
-Xms=3072M -Xmx=3072M -Xmn=1536M -XX:PermSize=256M -XX:MaxPermSize=256M -Xss=1M -XX:HandlePromotionFailure -XX:SurvivorRatio=8
```

其中-XX:SurvivorRatio=8是设置Eden区和Survivor区的比例，默认是8，也就是8：1：1，此时年轻代的Eden区是1.2G，两个S区各150M。所以，大概在JVM运行20秒左右就会进行一次Minor GC，假设每次GC能清理掉90%的对象，我们按照100M的存活对象算，那么这100M进入S区后大于了S区的一半，会触发动态年龄判断，将其中一部分对象移动老年代中，我们这里按照S区还有75M的存活对象算。

再经过20秒后，Eden区又产生了100M的存活对象，加上之前一个S区的50M存活对象(假设还存活50M对象)，这个数值超过了一个S区的上限(很可能会超过)，就会将这150M移动到老年代中，也就是现在的E区和S区的比例并不是很合适，需要调整JVM参数或是扩大S区的大小。

最好调整年轻代和老年代的比例 为2：1，也就是2G年轻代，1G老年代。

```java
-Xms=3072M -Xmx=3072M -Xmn=2048M -XX:PermSize=256M -XX:MaxPermSize=256M -Xss=1M -XX:HandlePromotionFailure -XX:SurvivorRatio=8
```

**如何调整？**

减小进入老年代的年龄判断上限：-XX:MaxTenuringThreshold=5，这样可以让那些长期存活的对象尽快进入老年代，少占用年轻代空间。

还有，如果创建的对象过大，也最大直接在老年代创建-XX:PretenureSizeThreshold=1M，尽量保证年轻代能创建更多小的对象。

指定垃圾回收器：-XX:+UseParNewGC -XX:+UseConcMarkSweepGC

再加上老年代保留的空闲空间比例：-XX:CMSInitiatingOccupancyFaction=92

和碎片内存清理参数：-XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0

就差不多了。

其实只需要保证年轻代的对象少进入老年代，常驻对象尽快进入老年代即可，性能一般不会太差。

![image-20210210103503212](https://alex-img-1253982387.cos.ap-nanjing.myqcloud.com/Typora/20210210103510.png)